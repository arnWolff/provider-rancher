/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AciNetworkProviderObservation struct {
	Aep *string `json:"aep,omitempty" tf:"aep,omitempty"`

	ApicHosts []*string `json:"apicHosts,omitempty" tf:"apic_hosts,omitempty"`

	ApicRefreshTickerAdjust *string `json:"apicRefreshTickerAdjust,omitempty" tf:"apic_refresh_ticker_adjust,omitempty"`

	ApicRefreshTime *string `json:"apicRefreshTime,omitempty" tf:"apic_refresh_time,omitempty"`

	ApicSubscriptionDelay *string `json:"apicSubscriptionDelay,omitempty" tf:"apic_subscription_delay,omitempty"`

	ApicUserName *string `json:"apicUserName,omitempty" tf:"apic_user_name,omitempty"`

	Capic *string `json:"capic,omitempty" tf:"capic,omitempty"`

	ControllerLogLevel *string `json:"controllerLogLevel,omitempty" tf:"controller_log_level,omitempty"`

	DisablePeriodicSnatGlobalInfoSync *string `json:"disablePeriodicSnatGlobalInfoSync,omitempty" tf:"disable_periodic_snat_global_info_sync,omitempty"`

	DisableWaitForNetwork *string `json:"disableWaitForNetwork,omitempty" tf:"disable_wait_for_network,omitempty"`

	DropLogEnable *string `json:"dropLogEnable,omitempty" tf:"drop_log_enable,omitempty"`

	DurationWaitForNetwork *string `json:"durationWaitForNetwork,omitempty" tf:"duration_wait_for_network,omitempty"`

	EnableEndpointSlice *string `json:"enableEndpointSlice,omitempty" tf:"enable_endpoint_slice,omitempty"`

	EncapType *string `json:"encapType,omitempty" tf:"encap_type,omitempty"`

	EpRegistry *string `json:"epRegistry,omitempty" tf:"ep_registry,omitempty"`

	ExternDynamic *string `json:"externDynamic,omitempty" tf:"extern_dynamic,omitempty"`

	ExternStatic *string `json:"externStatic,omitempty" tf:"extern_static,omitempty"`

	GbpPodSubnet *string `json:"gbpPodSubnet,omitempty" tf:"gbp_pod_subnet,omitempty"`

	HostAgentLogLevel *string `json:"hostAgentLogLevel,omitempty" tf:"host_agent_log_level,omitempty"`

	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" tf:"image_pull_policy,omitempty"`

	ImagePullSecret *string `json:"imagePullSecret,omitempty" tf:"image_pull_secret,omitempty"`

	InfraVlan *string `json:"infraVlan,omitempty" tf:"infra_vlan,omitempty"`

	InstallIstio *string `json:"installIstio,omitempty" tf:"install_istio,omitempty"`

	IstioProfile *string `json:"istioProfile,omitempty" tf:"istio_profile,omitempty"`

	KafkaBrokers []*string `json:"kafkaBrokers,omitempty" tf:"kafka_brokers,omitempty"`

	KafkaClientCrt *string `json:"kafkaClientCrt,omitempty" tf:"kafka_client_crt,omitempty"`

	KafkaClientKey *string `json:"kafkaClientKey,omitempty" tf:"kafka_client_key,omitempty"`

	KubeAPIVlan *string `json:"kubeApiVlan,omitempty" tf:"kube_api_vlan,omitempty"`

	L3Out *string `json:"l3out,omitempty" tf:"l3out,omitempty"`

	L3OutExternalNetworks []*string `json:"l3outExternalNetworks,omitempty" tf:"l3out_external_networks,omitempty"`

	MaxNodesSvcGraph *string `json:"maxNodesSvcGraph,omitempty" tf:"max_nodes_svc_graph,omitempty"`

	McastRangeEnd *string `json:"mcastRangeEnd,omitempty" tf:"mcast_range_end,omitempty"`

	McastRangeStart *string `json:"mcastRangeStart,omitempty" tf:"mcast_range_start,omitempty"`

	MtuHeadRoom *string `json:"mtuHeadRoom,omitempty" tf:"mtu_head_room,omitempty"`

	MultusDisable *string `json:"multusDisable,omitempty" tf:"multus_disable,omitempty"`

	NoPriorityClass *string `json:"noPriorityClass,omitempty" tf:"no_priority_class,omitempty"`

	NodePodIfEnable *string `json:"nodePodIfEnable,omitempty" tf:"node_pod_if_enable,omitempty"`

	NodeSubnet *string `json:"nodeSubnet,omitempty" tf:"node_subnet,omitempty"`

	NodeSvcSubnet *string `json:"nodeSvcSubnet,omitempty" tf:"node_svc_subnet,omitempty"`

	OpflexClientSSL *string `json:"opflexClientSsl,omitempty" tf:"opflex_client_ssl,omitempty"`

	OpflexDeviceDeleteTimeout *string `json:"opflexDeviceDeleteTimeout,omitempty" tf:"opflex_device_delete_timeout,omitempty"`

	OpflexLogLevel *string `json:"opflexLogLevel,omitempty" tf:"opflex_log_level,omitempty"`

	OpflexMode *string `json:"opflexMode,omitempty" tf:"opflex_mode,omitempty"`

	OpflexServerPort *string `json:"opflexServerPort,omitempty" tf:"opflex_server_port,omitempty"`

	OverlayVrfName *string `json:"overlayVrfName,omitempty" tf:"overlay_vrf_name,omitempty"`

	OvsMemoryLimit *string `json:"ovsMemoryLimit,omitempty" tf:"ovs_memory_limit,omitempty"`

	PbrTrackingNonSnat *string `json:"pbrTrackingNonSnat,omitempty" tf:"pbr_tracking_non_snat,omitempty"`

	PodSubnetChunkSize *string `json:"podSubnetChunkSize,omitempty" tf:"pod_subnet_chunk_size,omitempty"`

	RunGbpContainer *string `json:"runGbpContainer,omitempty" tf:"run_gbp_container,omitempty"`

	RunOpflexServerContainer *string `json:"runOpflexServerContainer,omitempty" tf:"run_opflex_server_container,omitempty"`

	ServiceMonitorInterval *string `json:"serviceMonitorInterval,omitempty" tf:"service_monitor_interval,omitempty"`

	ServiceVlan *string `json:"serviceVlan,omitempty" tf:"service_vlan,omitempty"`

	SnatContractScope *string `json:"snatContractScope,omitempty" tf:"snat_contract_scope,omitempty"`

	SnatNamespace *string `json:"snatNamespace,omitempty" tf:"snat_namespace,omitempty"`

	SnatPortRangeEnd *string `json:"snatPortRangeEnd,omitempty" tf:"snat_port_range_end,omitempty"`

	SnatPortRangeStart *string `json:"snatPortRangeStart,omitempty" tf:"snat_port_range_start,omitempty"`

	SnatPortsPerNode *string `json:"snatPortsPerNode,omitempty" tf:"snat_ports_per_node,omitempty"`

	SriovEnable *string `json:"sriovEnable,omitempty" tf:"sriov_enable,omitempty"`

	SubnetDomainName *string `json:"subnetDomainName,omitempty" tf:"subnet_domain_name,omitempty"`

	SystemID *string `json:"systemId,omitempty" tf:"system_id,omitempty"`

	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`

	UseAciAnywhereCrd *string `json:"useAciAnywhereCrd,omitempty" tf:"use_aci_anywhere_crd,omitempty"`

	UseAciCniPriorityClass *string `json:"useAciCniPriorityClass,omitempty" tf:"use_aci_cni_priority_class,omitempty"`

	UseClusterRole *string `json:"useClusterRole,omitempty" tf:"use_cluster_role,omitempty"`

	UseHostNetnsVolume *string `json:"useHostNetnsVolume,omitempty" tf:"use_host_netns_volume,omitempty"`

	UseOpflexServerVolume *string `json:"useOpflexServerVolume,omitempty" tf:"use_opflex_server_volume,omitempty"`

	UsePrivilegedContainer *string `json:"usePrivilegedContainer,omitempty" tf:"use_privileged_container,omitempty"`

	VmmController *string `json:"vmmController,omitempty" tf:"vmm_controller,omitempty"`

	VmmDomain *string `json:"vmmDomain,omitempty" tf:"vmm_domain,omitempty"`

	VrfName *string `json:"vrfName,omitempty" tf:"vrf_name,omitempty"`

	VrfTenant *string `json:"vrfTenant,omitempty" tf:"vrf_tenant,omitempty"`
}

type AciNetworkProviderParameters struct {

	// +kubebuilder:validation:Required
	Aep *string `json:"aep" tf:"aep,omitempty"`

	// +kubebuilder:validation:Required
	ApicHosts []*string `json:"apicHosts" tf:"apic_hosts,omitempty"`

	// +kubebuilder:validation:Optional
	ApicRefreshTickerAdjust *string `json:"apicRefreshTickerAdjust,omitempty" tf:"apic_refresh_ticker_adjust,omitempty"`

	// +kubebuilder:validation:Optional
	ApicRefreshTime *string `json:"apicRefreshTime,omitempty" tf:"apic_refresh_time,omitempty"`

	// +kubebuilder:validation:Optional
	ApicSubscriptionDelay *string `json:"apicSubscriptionDelay,omitempty" tf:"apic_subscription_delay,omitempty"`

	// +kubebuilder:validation:Required
	ApicUserCrtSecretRef v1.SecretKeySelector `json:"apicUserCrtSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	ApicUserKeySecretRef v1.SecretKeySelector `json:"apicUserKeySecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	ApicUserName *string `json:"apicUserName" tf:"apic_user_name,omitempty"`

	// +kubebuilder:validation:Optional
	Capic *string `json:"capic,omitempty" tf:"capic,omitempty"`

	// +kubebuilder:validation:Optional
	ControllerLogLevel *string `json:"controllerLogLevel,omitempty" tf:"controller_log_level,omitempty"`

	// +kubebuilder:validation:Optional
	DisablePeriodicSnatGlobalInfoSync *string `json:"disablePeriodicSnatGlobalInfoSync,omitempty" tf:"disable_periodic_snat_global_info_sync,omitempty"`

	// +kubebuilder:validation:Optional
	DisableWaitForNetwork *string `json:"disableWaitForNetwork,omitempty" tf:"disable_wait_for_network,omitempty"`

	// +kubebuilder:validation:Optional
	DropLogEnable *string `json:"dropLogEnable,omitempty" tf:"drop_log_enable,omitempty"`

	// +kubebuilder:validation:Optional
	DurationWaitForNetwork *string `json:"durationWaitForNetwork,omitempty" tf:"duration_wait_for_network,omitempty"`

	// +kubebuilder:validation:Optional
	EnableEndpointSlice *string `json:"enableEndpointSlice,omitempty" tf:"enable_endpoint_slice,omitempty"`

	// +kubebuilder:validation:Required
	EncapType *string `json:"encapType" tf:"encap_type,omitempty"`

	// +kubebuilder:validation:Optional
	EpRegistry *string `json:"epRegistry,omitempty" tf:"ep_registry,omitempty"`

	// +kubebuilder:validation:Required
	ExternDynamic *string `json:"externDynamic" tf:"extern_dynamic,omitempty"`

	// +kubebuilder:validation:Required
	ExternStatic *string `json:"externStatic" tf:"extern_static,omitempty"`

	// +kubebuilder:validation:Optional
	GbpPodSubnet *string `json:"gbpPodSubnet,omitempty" tf:"gbp_pod_subnet,omitempty"`

	// +kubebuilder:validation:Optional
	HostAgentLogLevel *string `json:"hostAgentLogLevel,omitempty" tf:"host_agent_log_level,omitempty"`

	// +kubebuilder:validation:Optional
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" tf:"image_pull_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ImagePullSecret *string `json:"imagePullSecret,omitempty" tf:"image_pull_secret,omitempty"`

	// +kubebuilder:validation:Optional
	InfraVlan *string `json:"infraVlan,omitempty" tf:"infra_vlan,omitempty"`

	// +kubebuilder:validation:Optional
	InstallIstio *string `json:"installIstio,omitempty" tf:"install_istio,omitempty"`

	// +kubebuilder:validation:Optional
	IstioProfile *string `json:"istioProfile,omitempty" tf:"istio_profile,omitempty"`

	// +kubebuilder:validation:Optional
	KafkaBrokers []*string `json:"kafkaBrokers,omitempty" tf:"kafka_brokers,omitempty"`

	// +kubebuilder:validation:Optional
	KafkaClientCrt *string `json:"kafkaClientCrt,omitempty" tf:"kafka_client_crt,omitempty"`

	// +kubebuilder:validation:Optional
	KafkaClientKey *string `json:"kafkaClientKey,omitempty" tf:"kafka_client_key,omitempty"`

	// +kubebuilder:validation:Required
	KubeAPIVlan *string `json:"kubeApiVlan" tf:"kube_api_vlan,omitempty"`

	// +kubebuilder:validation:Required
	L3Out *string `json:"l3out" tf:"l3out,omitempty"`

	// +kubebuilder:validation:Required
	L3OutExternalNetworks []*string `json:"l3outExternalNetworks" tf:"l3out_external_networks,omitempty"`

	// +kubebuilder:validation:Optional
	MaxNodesSvcGraph *string `json:"maxNodesSvcGraph,omitempty" tf:"max_nodes_svc_graph,omitempty"`

	// +kubebuilder:validation:Required
	McastRangeEnd *string `json:"mcastRangeEnd" tf:"mcast_range_end,omitempty"`

	// +kubebuilder:validation:Required
	McastRangeStart *string `json:"mcastRangeStart" tf:"mcast_range_start,omitempty"`

	// +kubebuilder:validation:Optional
	MtuHeadRoom *string `json:"mtuHeadRoom,omitempty" tf:"mtu_head_room,omitempty"`

	// +kubebuilder:validation:Optional
	MultusDisable *string `json:"multusDisable,omitempty" tf:"multus_disable,omitempty"`

	// +kubebuilder:validation:Optional
	NoPriorityClass *string `json:"noPriorityClass,omitempty" tf:"no_priority_class,omitempty"`

	// +kubebuilder:validation:Optional
	NodePodIfEnable *string `json:"nodePodIfEnable,omitempty" tf:"node_pod_if_enable,omitempty"`

	// +kubebuilder:validation:Required
	NodeSubnet *string `json:"nodeSubnet" tf:"node_subnet,omitempty"`

	// +kubebuilder:validation:Required
	NodeSvcSubnet *string `json:"nodeSvcSubnet" tf:"node_svc_subnet,omitempty"`

	// +kubebuilder:validation:Optional
	OpflexClientSSL *string `json:"opflexClientSsl,omitempty" tf:"opflex_client_ssl,omitempty"`

	// +kubebuilder:validation:Optional
	OpflexDeviceDeleteTimeout *string `json:"opflexDeviceDeleteTimeout,omitempty" tf:"opflex_device_delete_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	OpflexLogLevel *string `json:"opflexLogLevel,omitempty" tf:"opflex_log_level,omitempty"`

	// +kubebuilder:validation:Optional
	OpflexMode *string `json:"opflexMode,omitempty" tf:"opflex_mode,omitempty"`

	// +kubebuilder:validation:Optional
	OpflexServerPort *string `json:"opflexServerPort,omitempty" tf:"opflex_server_port,omitempty"`

	// +kubebuilder:validation:Optional
	OverlayVrfName *string `json:"overlayVrfName,omitempty" tf:"overlay_vrf_name,omitempty"`

	// +kubebuilder:validation:Optional
	OvsMemoryLimit *string `json:"ovsMemoryLimit,omitempty" tf:"ovs_memory_limit,omitempty"`

	// +kubebuilder:validation:Optional
	PbrTrackingNonSnat *string `json:"pbrTrackingNonSnat,omitempty" tf:"pbr_tracking_non_snat,omitempty"`

	// +kubebuilder:validation:Optional
	PodSubnetChunkSize *string `json:"podSubnetChunkSize,omitempty" tf:"pod_subnet_chunk_size,omitempty"`

	// +kubebuilder:validation:Optional
	RunGbpContainer *string `json:"runGbpContainer,omitempty" tf:"run_gbp_container,omitempty"`

	// +kubebuilder:validation:Optional
	RunOpflexServerContainer *string `json:"runOpflexServerContainer,omitempty" tf:"run_opflex_server_container,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceMonitorInterval *string `json:"serviceMonitorInterval,omitempty" tf:"service_monitor_interval,omitempty"`

	// +kubebuilder:validation:Required
	ServiceVlan *string `json:"serviceVlan" tf:"service_vlan,omitempty"`

	// +kubebuilder:validation:Optional
	SnatContractScope *string `json:"snatContractScope,omitempty" tf:"snat_contract_scope,omitempty"`

	// +kubebuilder:validation:Optional
	SnatNamespace *string `json:"snatNamespace,omitempty" tf:"snat_namespace,omitempty"`

	// +kubebuilder:validation:Optional
	SnatPortRangeEnd *string `json:"snatPortRangeEnd,omitempty" tf:"snat_port_range_end,omitempty"`

	// +kubebuilder:validation:Optional
	SnatPortRangeStart *string `json:"snatPortRangeStart,omitempty" tf:"snat_port_range_start,omitempty"`

	// +kubebuilder:validation:Optional
	SnatPortsPerNode *string `json:"snatPortsPerNode,omitempty" tf:"snat_ports_per_node,omitempty"`

	// +kubebuilder:validation:Optional
	SriovEnable *string `json:"sriovEnable,omitempty" tf:"sriov_enable,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetDomainName *string `json:"subnetDomainName,omitempty" tf:"subnet_domain_name,omitempty"`

	// +kubebuilder:validation:Required
	SystemID *string `json:"systemId" tf:"system_id,omitempty"`

	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`

	// +kubebuilder:validation:Required
	TokenSecretRef v1.SecretKeySelector `json:"tokenSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	UseAciAnywhereCrd *string `json:"useAciAnywhereCrd,omitempty" tf:"use_aci_anywhere_crd,omitempty"`

	// +kubebuilder:validation:Optional
	UseAciCniPriorityClass *string `json:"useAciCniPriorityClass,omitempty" tf:"use_aci_cni_priority_class,omitempty"`

	// +kubebuilder:validation:Optional
	UseClusterRole *string `json:"useClusterRole,omitempty" tf:"use_cluster_role,omitempty"`

	// +kubebuilder:validation:Optional
	UseHostNetnsVolume *string `json:"useHostNetnsVolume,omitempty" tf:"use_host_netns_volume,omitempty"`

	// +kubebuilder:validation:Optional
	UseOpflexServerVolume *string `json:"useOpflexServerVolume,omitempty" tf:"use_opflex_server_volume,omitempty"`

	// +kubebuilder:validation:Optional
	UsePrivilegedContainer *string `json:"usePrivilegedContainer,omitempty" tf:"use_privileged_container,omitempty"`

	// +kubebuilder:validation:Optional
	VmmController *string `json:"vmmController,omitempty" tf:"vmm_controller,omitempty"`

	// +kubebuilder:validation:Optional
	VmmDomain *string `json:"vmmDomain,omitempty" tf:"vmm_domain,omitempty"`

	// +kubebuilder:validation:Required
	VrfName *string `json:"vrfName" tf:"vrf_name,omitempty"`

	// +kubebuilder:validation:Required
	VrfTenant *string `json:"vrfTenant" tf:"vrf_tenant,omitempty"`
}

type AgentEnvVarsObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AgentEnvVarsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type AksConfigObservation struct {

	// The administrator username to use for Linux hosts
	AdminUsername *string `json:"adminUsername,omitempty" tf:"admin_username,omitempty"`

	// DNS prefix to be used to create the FQDN for the agent pool
	AgentDNSPrefix *string `json:"agentDnsPrefix,omitempty" tf:"agent_dns_prefix,omitempty"`

	// GB size to be used to specify the disk for every machine in the agent pool. If you specify 0, it will apply the default according to the "agent vm size" specified
	AgentOsDiskSize *float64 `json:"agentOsDiskSize,omitempty" tf:"agent_os_disk_size,omitempty"`

	// Name for the agent pool, upto 12 alphanumeric characters
	AgentPoolName *string `json:"agentPoolName,omitempty" tf:"agent_pool_name,omitempty"`

	// Storage profile specifies what kind of storage used on machine in the agent pool. Chooses from [ManagedDisks StorageAccount]
	AgentStorageProfile *string `json:"agentStorageProfile,omitempty" tf:"agent_storage_profile,omitempty"`

	// Size of machine in the agent pool
	AgentVMSize *string `json:"agentVmSize,omitempty" tf:"agent_vm_size,omitempty"`

	// Different authentication API url to use
	AuthBaseURL *string `json:"authBaseUrl,omitempty" tf:"auth_base_url,omitempty"`

	// Different resource management API url to use
	BaseURL *string `json:"baseUrl,omitempty" tf:"base_url,omitempty"`

	// Number of machines (VMs) in the agent pool. Allowed values must be in the range of 1 to 100 (inclusive)
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`

	// An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes Service address range specified in "service cidr"
	DNSServiceIP *string `json:"dnsServiceIp,omitempty" tf:"dns_service_ip,omitempty"`

	// A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes Service address range specified in "service cidr"
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty" tf:"docker_bridge_cidr,omitempty"`

	// Enable the Kubernetes ingress with automatic public DNS name creation
	EnableHTTPApplicationRouting *bool `json:"enableHttpApplicationRouting,omitempty" tf:"enable_http_application_routing,omitempty"`

	// Turn on Azure Log Analytics monitoring. Uses the Log Analytics "Default" workspace if it exists, else creates one. if using an existing workspace, specifies "log analytics workspace resource id"
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" tf:"enable_monitoring,omitempty"`

	// Specify the version of Kubernetes
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Load balancer type (basic | standard). Must be standard for auto-scaling
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// Azure Kubernetes cluster location
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The name of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses '{resource group}-{subscription id}-{location code}'
	LogAnalyticsWorkspace *string `json:"logAnalyticsWorkspace,omitempty" tf:"log_analytics_workspace,omitempty"`

	// The resource group of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses the 'Cluster' resource group
	LogAnalyticsWorkspaceResourceGroup *string `json:"logAnalyticsWorkspaceResourceGroup,omitempty" tf:"log_analytics_workspace_resource_group,omitempty"`

	// DNS prefix to use the Kubernetes cluster control pane
	MasterDNSPrefix *string `json:"masterDnsPrefix,omitempty" tf:"master_dns_prefix,omitempty"`

	// Maximum number of pods that can run on a node
	MaxPods *float64 `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// Network plugin used for building Kubernetes network. Chooses from [azure kubenet]
	NetworkPlugin *string `json:"networkPlugin,omitempty" tf:"network_plugin,omitempty"`

	// Network policy used for building Kubernetes network. Chooses from [calico]
	NetworkPolicy *string `json:"networkPolicy,omitempty" tf:"network_policy,omitempty"`

	// A CIDR notation IP range from which to assign Kubernetes Pod IPs when "network plugin" is specified in "kubenet".
	PodCidr *string `json:"podCidr,omitempty" tf:"pod_cidr,omitempty"`

	// The name of the Cluster resource group
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// Contents of the SSH public key used to authenticate with Linux hosts
	SSHPublicKeyContents *string `json:"sshPublicKeyContents,omitempty" tf:"ssh_public_key_contents,omitempty"`

	// A CIDR notation IP range from which to assign Kubernetes Service cluster IPs. It must not overlap with any Subnet IP ranges
	ServiceCidr *string `json:"serviceCidr,omitempty" tf:"service_cidr,omitempty"`

	// The name of an existing Azure Virtual Subnet. Composite of agent virtual network subnet ID
	Subnet *string `json:"subnet,omitempty" tf:"subnet,omitempty"`

	// Subscription credentials which uniquely identify Microsoft Azure subscription
	SubscriptionID *string `json:"subscriptionId,omitempty" tf:"subscription_id,omitempty"`

	// Tags for Kubernetes cluster. For example, foo=bar
	Tag map[string]*string `json:"tag,omitempty" tf:"tag,omitempty"`

	// Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]`
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Azure tenant ID to use
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`

	// The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
	VirtualNetwork *string `json:"virtualNetwork,omitempty" tf:"virtual_network,omitempty"`

	// The resource group of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
	VirtualNetworkResourceGroup *string `json:"virtualNetworkResourceGroup,omitempty" tf:"virtual_network_resource_group,omitempty"`
}

type AksConfigParameters struct {

	// The secret of an Azure Active Directory server application
	// +kubebuilder:validation:Optional
	AadServerAppSecretSecretRef *v1.SecretKeySelector `json:"aadServerAppSecretSecretRef,omitempty" tf:"-"`

	// The ID of an Azure Active Directory tenant
	// +kubebuilder:validation:Optional
	AadTenantIDSecretRef *v1.SecretKeySelector `json:"aadTenantIdSecretRef,omitempty" tf:"-"`

	// The ID of an Azure Active Directory client application of type "Native". This application is for user login via kubectl
	// +kubebuilder:validation:Optional
	AddClientAppIDSecretRef *v1.SecretKeySelector `json:"addClientAppIdSecretRef,omitempty" tf:"-"`

	// The ID of an Azure Active Directory server application of type "Web app/API". This application represents the managed cluster's apiserver (Server application)
	// +kubebuilder:validation:Optional
	AddServerAppIDSecretRef *v1.SecretKeySelector `json:"addServerAppIdSecretRef,omitempty" tf:"-"`

	// The administrator username to use for Linux hosts
	// +kubebuilder:validation:Optional
	AdminUsername *string `json:"adminUsername,omitempty" tf:"admin_username,omitempty"`

	// DNS prefix to be used to create the FQDN for the agent pool
	// +kubebuilder:validation:Required
	AgentDNSPrefix *string `json:"agentDnsPrefix" tf:"agent_dns_prefix,omitempty"`

	// GB size to be used to specify the disk for every machine in the agent pool. If you specify 0, it will apply the default according to the "agent vm size" specified
	// +kubebuilder:validation:Optional
	AgentOsDiskSize *float64 `json:"agentOsDiskSize,omitempty" tf:"agent_os_disk_size,omitempty"`

	// Name for the agent pool, upto 12 alphanumeric characters
	// +kubebuilder:validation:Optional
	AgentPoolName *string `json:"agentPoolName,omitempty" tf:"agent_pool_name,omitempty"`

	// Storage profile specifies what kind of storage used on machine in the agent pool. Chooses from [ManagedDisks StorageAccount]
	// +kubebuilder:validation:Optional
	AgentStorageProfile *string `json:"agentStorageProfile,omitempty" tf:"agent_storage_profile,omitempty"`

	// Size of machine in the agent pool
	// +kubebuilder:validation:Optional
	AgentVMSize *string `json:"agentVmSize,omitempty" tf:"agent_vm_size,omitempty"`

	// Different authentication API url to use
	// +kubebuilder:validation:Optional
	AuthBaseURL *string `json:"authBaseUrl,omitempty" tf:"auth_base_url,omitempty"`

	// Different resource management API url to use
	// +kubebuilder:validation:Optional
	BaseURL *string `json:"baseUrl,omitempty" tf:"base_url,omitempty"`

	// Azure client ID to use
	// +kubebuilder:validation:Required
	ClientIDSecretRef v1.SecretKeySelector `json:"clientIdSecretRef" tf:"-"`

	// Azure client secret associated with the "client id"
	// +kubebuilder:validation:Required
	ClientSecretSecretRef v1.SecretKeySelector `json:"clientSecretSecretRef" tf:"-"`

	// Number of machines (VMs) in the agent pool. Allowed values must be in the range of 1 to 100 (inclusive)
	// +kubebuilder:validation:Optional
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`

	// An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes Service address range specified in "service cidr"
	// +kubebuilder:validation:Optional
	DNSServiceIP *string `json:"dnsServiceIp,omitempty" tf:"dns_service_ip,omitempty"`

	// A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes Service address range specified in "service cidr"
	// +kubebuilder:validation:Optional
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty" tf:"docker_bridge_cidr,omitempty"`

	// Enable the Kubernetes ingress with automatic public DNS name creation
	// +kubebuilder:validation:Optional
	EnableHTTPApplicationRouting *bool `json:"enableHttpApplicationRouting,omitempty" tf:"enable_http_application_routing,omitempty"`

	// Turn on Azure Log Analytics monitoring. Uses the Log Analytics "Default" workspace if it exists, else creates one. if using an existing workspace, specifies "log analytics workspace resource id"
	// +kubebuilder:validation:Optional
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" tf:"enable_monitoring,omitempty"`

	// Specify the version of Kubernetes
	// +kubebuilder:validation:Required
	KubernetesVersion *string `json:"kubernetesVersion" tf:"kubernetes_version,omitempty"`

	// Load balancer type (basic | standard). Must be standard for auto-scaling
	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// Azure Kubernetes cluster location
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The name of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses '{resource group}-{subscription id}-{location code}'
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspace *string `json:"logAnalyticsWorkspace,omitempty" tf:"log_analytics_workspace,omitempty"`

	// The resource group of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses the 'Cluster' resource group
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspaceResourceGroup *string `json:"logAnalyticsWorkspaceResourceGroup,omitempty" tf:"log_analytics_workspace_resource_group,omitempty"`

	// DNS prefix to use the Kubernetes cluster control pane
	// +kubebuilder:validation:Required
	MasterDNSPrefix *string `json:"masterDnsPrefix" tf:"master_dns_prefix,omitempty"`

	// Maximum number of pods that can run on a node
	// +kubebuilder:validation:Optional
	MaxPods *float64 `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// Network plugin used for building Kubernetes network. Chooses from [azure kubenet]
	// +kubebuilder:validation:Optional
	NetworkPlugin *string `json:"networkPlugin,omitempty" tf:"network_plugin,omitempty"`

	// Network policy used for building Kubernetes network. Chooses from [calico]
	// +kubebuilder:validation:Optional
	NetworkPolicy *string `json:"networkPolicy,omitempty" tf:"network_policy,omitempty"`

	// A CIDR notation IP range from which to assign Kubernetes Pod IPs when "network plugin" is specified in "kubenet".
	// +kubebuilder:validation:Optional
	PodCidr *string `json:"podCidr,omitempty" tf:"pod_cidr,omitempty"`

	// The name of the Cluster resource group
	// +kubebuilder:validation:Required
	ResourceGroup *string `json:"resourceGroup" tf:"resource_group,omitempty"`

	// Contents of the SSH public key used to authenticate with Linux hosts
	// +kubebuilder:validation:Required
	SSHPublicKeyContents *string `json:"sshPublicKeyContents" tf:"ssh_public_key_contents,omitempty"`

	// A CIDR notation IP range from which to assign Kubernetes Service cluster IPs. It must not overlap with any Subnet IP ranges
	// +kubebuilder:validation:Optional
	ServiceCidr *string `json:"serviceCidr,omitempty" tf:"service_cidr,omitempty"`

	// The name of an existing Azure Virtual Subnet. Composite of agent virtual network subnet ID
	// +kubebuilder:validation:Required
	Subnet *string `json:"subnet" tf:"subnet,omitempty"`

	// Subscription credentials which uniquely identify Microsoft Azure subscription
	// +kubebuilder:validation:Required
	SubscriptionID *string `json:"subscriptionId" tf:"subscription_id,omitempty"`

	// Tags for Kubernetes cluster. For example, foo=bar
	// +kubebuilder:validation:Optional
	Tag map[string]*string `json:"tag,omitempty" tf:"tag,omitempty"`

	// Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]`
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Azure tenant ID to use
	// +kubebuilder:validation:Required
	TenantID *string `json:"tenantId" tf:"tenant_id,omitempty"`

	// The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
	// +kubebuilder:validation:Required
	VirtualNetwork *string `json:"virtualNetwork" tf:"virtual_network,omitempty"`

	// The resource group of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
	// +kubebuilder:validation:Required
	VirtualNetworkResourceGroup *string `json:"virtualNetworkResourceGroup" tf:"virtual_network_resource_group,omitempty"`
}

type AksConfigV2Observation struct {

	// The AKS auth base url
	AuthBaseURL *string `json:"authBaseUrl,omitempty" tf:"auth_base_url,omitempty"`

	// The AKS authorized ip ranges
	AuthorizedIPRanges []*string `json:"authorizedIpRanges,omitempty" tf:"authorized_ip_ranges,omitempty"`

	// The AKS base url
	BaseURL *string `json:"baseUrl,omitempty" tf:"base_url,omitempty"`

	// The AKS Cloud Credential ID to use
	CloudCredentialID *string `json:"cloudCredentialId,omitempty" tf:"cloud_credential_id,omitempty"`

	// The AKS dns prefix. Required if `import=false`
	DNSPrefix *string `json:"dnsPrefix,omitempty" tf:"dns_prefix,omitempty"`

	// Enable AKS http application routing?
	HTTPApplicationRouting *bool `json:"httpApplicationRouting,omitempty" tf:"http_application_routing,omitempty"`

	// Is AKS cluster imported?
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// The kubernetes master version. Required if `import=false`
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The AKS linux admin username
	LinuxAdminUsername *string `json:"linuxAdminUsername,omitempty" tf:"linux_admin_username,omitempty"`

	// The AKS linux ssh public key
	LinuxSSHPublicKey *string `json:"linuxSshPublicKey,omitempty" tf:"linux_ssh_public_key,omitempty"`

	// The AKS load balancer sku
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// The AKS log analytics workspace group
	LogAnalyticsWorkspaceGroup *string `json:"logAnalyticsWorkspaceGroup,omitempty" tf:"log_analytics_workspace_group,omitempty"`

	// The AKS log analytics workspace name
	LogAnalyticsWorkspaceName *string `json:"logAnalyticsWorkspaceName,omitempty" tf:"log_analytics_workspace_name,omitempty"`

	// Is AKS cluster monitoring enabled?
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// The AKS cluster name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The AKS network dns service ip
	NetworkDNSServiceIP *string `json:"networkDnsServiceIp,omitempty" tf:"network_dns_service_ip,omitempty"`

	// The AKS network docker bridge cidr
	NetworkDockerBridgeCidr *string `json:"networkDockerBridgeCidr,omitempty" tf:"network_docker_bridge_cidr,omitempty"`

	// The AKS network plugin. Required if `import=false`
	NetworkPlugin *string `json:"networkPlugin,omitempty" tf:"network_plugin,omitempty"`

	// The AKS network pod cidr
	NetworkPodCidr *string `json:"networkPodCidr,omitempty" tf:"network_pod_cidr,omitempty"`

	// The AKS network policy
	NetworkPolicy *string `json:"networkPolicy,omitempty" tf:"network_policy,omitempty"`

	// The AKS network service cidr
	NetworkServiceCidr *string `json:"networkServiceCidr,omitempty" tf:"network_service_cidr,omitempty"`

	// The AKS node pools to use. Required if `import=false`
	NodePools []NodePoolsObservation `json:"nodePools,omitempty" tf:"node_pools,omitempty"`

	// Is AKS cluster private?
	PrivateCluster *bool `json:"privateCluster,omitempty" tf:"private_cluster,omitempty"`

	// The AKS resource group
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// The AKS resource location
	ResourceLocation *string `json:"resourceLocation,omitempty" tf:"resource_location,omitempty"`

	// The AKS subnet
	Subnet *string `json:"subnet,omitempty" tf:"subnet,omitempty"`

	// The AKS cluster tags
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The AKS virtual network
	VirtualNetwork *string `json:"virtualNetwork,omitempty" tf:"virtual_network,omitempty"`

	// The AKS virtual network resource group
	VirtualNetworkResourceGroup *string `json:"virtualNetworkResourceGroup,omitempty" tf:"virtual_network_resource_group,omitempty"`
}

type AksConfigV2Parameters struct {

	// The AKS auth base url
	// +kubebuilder:validation:Optional
	AuthBaseURL *string `json:"authBaseUrl,omitempty" tf:"auth_base_url,omitempty"`

	// The AKS authorized ip ranges
	// +kubebuilder:validation:Optional
	AuthorizedIPRanges []*string `json:"authorizedIpRanges,omitempty" tf:"authorized_ip_ranges,omitempty"`

	// The AKS base url
	// +kubebuilder:validation:Optional
	BaseURL *string `json:"baseUrl,omitempty" tf:"base_url,omitempty"`

	// The AKS Cloud Credential ID to use
	// +kubebuilder:validation:Required
	CloudCredentialID *string `json:"cloudCredentialId" tf:"cloud_credential_id,omitempty"`

	// The AKS dns prefix. Required if `import=false`
	// +kubebuilder:validation:Optional
	DNSPrefix *string `json:"dnsPrefix,omitempty" tf:"dns_prefix,omitempty"`

	// Enable AKS http application routing?
	// +kubebuilder:validation:Optional
	HTTPApplicationRouting *bool `json:"httpApplicationRouting,omitempty" tf:"http_application_routing,omitempty"`

	// Is AKS cluster imported?
	// +kubebuilder:validation:Optional
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// The kubernetes master version. Required if `import=false`
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The AKS linux admin username
	// +kubebuilder:validation:Optional
	LinuxAdminUsername *string `json:"linuxAdminUsername,omitempty" tf:"linux_admin_username,omitempty"`

	// The AKS linux ssh public key
	// +kubebuilder:validation:Optional
	LinuxSSHPublicKey *string `json:"linuxSshPublicKey,omitempty" tf:"linux_ssh_public_key,omitempty"`

	// The AKS load balancer sku
	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// The AKS log analytics workspace group
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspaceGroup *string `json:"logAnalyticsWorkspaceGroup,omitempty" tf:"log_analytics_workspace_group,omitempty"`

	// The AKS log analytics workspace name
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspaceName *string `json:"logAnalyticsWorkspaceName,omitempty" tf:"log_analytics_workspace_name,omitempty"`

	// Is AKS cluster monitoring enabled?
	// +kubebuilder:validation:Optional
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// The AKS cluster name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The AKS network dns service ip
	// +kubebuilder:validation:Optional
	NetworkDNSServiceIP *string `json:"networkDnsServiceIp,omitempty" tf:"network_dns_service_ip,omitempty"`

	// The AKS network docker bridge cidr
	// +kubebuilder:validation:Optional
	NetworkDockerBridgeCidr *string `json:"networkDockerBridgeCidr,omitempty" tf:"network_docker_bridge_cidr,omitempty"`

	// The AKS network plugin. Required if `import=false`
	// +kubebuilder:validation:Optional
	NetworkPlugin *string `json:"networkPlugin,omitempty" tf:"network_plugin,omitempty"`

	// The AKS network pod cidr
	// +kubebuilder:validation:Optional
	NetworkPodCidr *string `json:"networkPodCidr,omitempty" tf:"network_pod_cidr,omitempty"`

	// The AKS network policy
	// +kubebuilder:validation:Optional
	NetworkPolicy *string `json:"networkPolicy,omitempty" tf:"network_policy,omitempty"`

	// The AKS network service cidr
	// +kubebuilder:validation:Optional
	NetworkServiceCidr *string `json:"networkServiceCidr,omitempty" tf:"network_service_cidr,omitempty"`

	// The AKS node pools to use. Required if `import=false`
	// +kubebuilder:validation:Optional
	NodePools []NodePoolsParameters `json:"nodePools,omitempty" tf:"node_pools,omitempty"`

	// Is AKS cluster private?
	// +kubebuilder:validation:Optional
	PrivateCluster *bool `json:"privateCluster,omitempty" tf:"private_cluster,omitempty"`

	// The AKS resource group
	// +kubebuilder:validation:Required
	ResourceGroup *string `json:"resourceGroup" tf:"resource_group,omitempty"`

	// The AKS resource location
	// +kubebuilder:validation:Required
	ResourceLocation *string `json:"resourceLocation" tf:"resource_location,omitempty"`

	// The AKS subnet
	// +kubebuilder:validation:Optional
	Subnet *string `json:"subnet,omitempty" tf:"subnet,omitempty"`

	// The AKS cluster tags
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The AKS virtual network
	// +kubebuilder:validation:Optional
	VirtualNetwork *string `json:"virtualNetwork,omitempty" tf:"virtual_network,omitempty"`

	// The AKS virtual network resource group
	// +kubebuilder:validation:Optional
	VirtualNetworkResourceGroup *string `json:"virtualNetworkResourceGroup,omitempty" tf:"virtual_network_resource_group,omitempty"`
}

type AuditLogObservation struct {
	Configuration []ConfigurationObservation `json:"configuration,omitempty" tf:"configuration,omitempty"`

	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AuditLogParameters struct {

	// +kubebuilder:validation:Optional
	Configuration []ConfigurationParameters `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AuthenticationObservation struct {
	Sans []*string `json:"sans,omitempty" tf:"sans,omitempty"`

	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type AuthenticationParameters struct {

	// +kubebuilder:validation:Optional
	Sans []*string `json:"sans,omitempty" tf:"sans,omitempty"`

	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type AuthorizationObservation struct {
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`
}

type AuthorizationParameters struct {

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`
}

type AutoscalingObservation struct {

	// Enable GKE node pool config autoscaling
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The GKE node pool config max node count
	MaxNodeCount *float64 `json:"maxNodeCount,omitempty" tf:"max_node_count,omitempty"`

	// The GKE node pool config min node count
	MinNodeCount *float64 `json:"minNodeCount,omitempty" tf:"min_node_count,omitempty"`
}

type AutoscalingParameters struct {

	// Enable GKE node pool config autoscaling
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The GKE node pool config max node count
	// +kubebuilder:validation:Optional
	MaxNodeCount *float64 `json:"maxNodeCount,omitempty" tf:"max_node_count,omitempty"`

	// The GKE node pool config min node count
	// +kubebuilder:validation:Optional
	MinNodeCount *float64 `json:"minNodeCount,omitempty" tf:"min_node_count,omitempty"`
}

type AwsCloudProviderObservation struct {
	Global []GlobalObservation `json:"global,omitempty" tf:"global,omitempty"`

	ServiceOverride []ServiceOverrideObservation `json:"serviceOverride,omitempty" tf:"service_override,omitempty"`
}

type AwsCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	Global []GlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceOverride []ServiceOverrideParameters `json:"serviceOverride,omitempty" tf:"service_override,omitempty"`
}

type AzureCloudProviderObservation struct {
	AadClientCertPath *string `json:"aadClientCertPath,omitempty" tf:"aad_client_cert_path,omitempty"`

	Cloud *string `json:"cloud,omitempty" tf:"cloud,omitempty"`

	CloudProviderBackoff *bool `json:"cloudProviderBackoff,omitempty" tf:"cloud_provider_backoff,omitempty"`

	CloudProviderBackoffDuration *float64 `json:"cloudProviderBackoffDuration,omitempty" tf:"cloud_provider_backoff_duration,omitempty"`

	CloudProviderBackoffExponent *float64 `json:"cloudProviderBackoffExponent,omitempty" tf:"cloud_provider_backoff_exponent,omitempty"`

	CloudProviderBackoffJitter *float64 `json:"cloudProviderBackoffJitter,omitempty" tf:"cloud_provider_backoff_jitter,omitempty"`

	CloudProviderBackoffRetries *float64 `json:"cloudProviderBackoffRetries,omitempty" tf:"cloud_provider_backoff_retries,omitempty"`

	CloudProviderRateLimit *bool `json:"cloudProviderRateLimit,omitempty" tf:"cloud_provider_rate_limit,omitempty"`

	CloudProviderRateLimitBucket *float64 `json:"cloudProviderRateLimitBucket,omitempty" tf:"cloud_provider_rate_limit_bucket,omitempty"`

	CloudProviderRateLimitQPS *float64 `json:"cloudProviderRateLimitQps,omitempty" tf:"cloud_provider_rate_limit_qps,omitempty"`

	// Load balancer type (basic | standard). Must be standard for auto-scaling
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	MaximumLoadBalancerRuleCount *float64 `json:"maximumLoadBalancerRuleCount,omitempty" tf:"maximum_load_balancer_rule_count,omitempty"`

	PrimaryAvailabilitySetName *string `json:"primaryAvailabilitySetName,omitempty" tf:"primary_availability_set_name,omitempty"`

	PrimaryScaleSetName *string `json:"primaryScaleSetName,omitempty" tf:"primary_scale_set_name,omitempty"`

	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	RouteTableName *string `json:"routeTableName,omitempty" tf:"route_table_name,omitempty"`

	SecurityGroupName *string `json:"securityGroupName,omitempty" tf:"security_group_name,omitempty"`

	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`

	UseInstanceMetadata *bool `json:"useInstanceMetadata,omitempty" tf:"use_instance_metadata,omitempty"`

	UseManagedIdentityExtension *bool `json:"useManagedIdentityExtension,omitempty" tf:"use_managed_identity_extension,omitempty"`

	VMType *string `json:"vmType,omitempty" tf:"vm_type,omitempty"`

	VnetName *string `json:"vnetName,omitempty" tf:"vnet_name,omitempty"`

	VnetResourceGroup *string `json:"vnetResourceGroup,omitempty" tf:"vnet_resource_group,omitempty"`
}

type AzureCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	AadClientCertPasswordSecretRef *v1.SecretKeySelector `json:"aadClientCertPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	AadClientCertPath *string `json:"aadClientCertPath,omitempty" tf:"aad_client_cert_path,omitempty"`

	// +kubebuilder:validation:Required
	AadClientIDSecretRef v1.SecretKeySelector `json:"aadClientIdSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	AadClientSecretSecretRef v1.SecretKeySelector `json:"aadClientSecretSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Cloud *string `json:"cloud,omitempty" tf:"cloud,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoff *bool `json:"cloudProviderBackoff,omitempty" tf:"cloud_provider_backoff,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffDuration *float64 `json:"cloudProviderBackoffDuration,omitempty" tf:"cloud_provider_backoff_duration,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffExponent *float64 `json:"cloudProviderBackoffExponent,omitempty" tf:"cloud_provider_backoff_exponent,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffJitter *float64 `json:"cloudProviderBackoffJitter,omitempty" tf:"cloud_provider_backoff_jitter,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffRetries *float64 `json:"cloudProviderBackoffRetries,omitempty" tf:"cloud_provider_backoff_retries,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimit *bool `json:"cloudProviderRateLimit,omitempty" tf:"cloud_provider_rate_limit,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimitBucket *float64 `json:"cloudProviderRateLimitBucket,omitempty" tf:"cloud_provider_rate_limit_bucket,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimitQPS *float64 `json:"cloudProviderRateLimitQps,omitempty" tf:"cloud_provider_rate_limit_qps,omitempty"`

	// Load balancer type (basic | standard). Must be standard for auto-scaling
	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	MaximumLoadBalancerRuleCount *float64 `json:"maximumLoadBalancerRuleCount,omitempty" tf:"maximum_load_balancer_rule_count,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryAvailabilitySetName *string `json:"primaryAvailabilitySetName,omitempty" tf:"primary_availability_set_name,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryScaleSetName *string `json:"primaryScaleSetName,omitempty" tf:"primary_scale_set_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// +kubebuilder:validation:Optional
	RouteTableName *string `json:"routeTableName,omitempty" tf:"route_table_name,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupName *string `json:"securityGroupName,omitempty" tf:"security_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`

	// +kubebuilder:validation:Required
	SubscriptionIDSecretRef v1.SecretKeySelector `json:"subscriptionIdSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	TenantIDSecretRef v1.SecretKeySelector `json:"tenantIdSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	UseInstanceMetadata *bool `json:"useInstanceMetadata,omitempty" tf:"use_instance_metadata,omitempty"`

	// +kubebuilder:validation:Optional
	UseManagedIdentityExtension *bool `json:"useManagedIdentityExtension,omitempty" tf:"use_managed_identity_extension,omitempty"`

	// +kubebuilder:validation:Optional
	VMType *string `json:"vmType,omitempty" tf:"vm_type,omitempty"`

	// +kubebuilder:validation:Optional
	VnetName *string `json:"vnetName,omitempty" tf:"vnet_name,omitempty"`

	// +kubebuilder:validation:Optional
	VnetResourceGroup *string `json:"vnetResourceGroup,omitempty" tf:"vnet_resource_group,omitempty"`
}

type BackupConfigObservation struct {
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	IntervalHours *float64 `json:"intervalHours,omitempty" tf:"interval_hours,omitempty"`

	Retention *float64 `json:"retention,omitempty" tf:"retention,omitempty"`

	S3BackupConfig []S3BackupConfigObservation `json:"s3BackupConfig,omitempty" tf:"s3_backup_config,omitempty"`

	SafeTimestamp *bool `json:"safeTimestamp,omitempty" tf:"safe_timestamp,omitempty"`

	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type BackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalHours *float64 `json:"intervalHours,omitempty" tf:"interval_hours,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *float64 `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	S3BackupConfig []S3BackupConfigParameters `json:"s3BackupConfig,omitempty" tf:"s3_backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	SafeTimestamp *bool `json:"safeTimestamp,omitempty" tf:"safe_timestamp,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type BastionHostObservation struct {
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	User *string `json:"user,omitempty" tf:"user,omitempty"`
}

type BastionHostParameters struct {

	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeySecretRef *v1.SecretKeySelector `json:"sshKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	User *string `json:"user" tf:"user,omitempty"`
}

type BlockStorageObservation struct {
	BsVersion *string `json:"bsVersion,omitempty" tf:"bs_version,omitempty"`

	IgnoreVolumeAz *bool `json:"ignoreVolumeAz,omitempty" tf:"ignore_volume_az,omitempty"`

	TrustDevicePath *bool `json:"trustDevicePath,omitempty" tf:"trust_device_path,omitempty"`
}

type BlockStorageParameters struct {

	// +kubebuilder:validation:Optional
	BsVersion *string `json:"bsVersion,omitempty" tf:"bs_version,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreVolumeAz *bool `json:"ignoreVolumeAz,omitempty" tf:"ignore_volume_az,omitempty"`

	// +kubebuilder:validation:Optional
	TrustDevicePath *bool `json:"trustDevicePath,omitempty" tf:"trust_device_path,omitempty"`
}

type CalicoNetworkProviderObservation struct {
	CloudProvider *string `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`
}

type CalicoNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	CloudProvider *string `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`
}

type CanalNetworkProviderObservation struct {
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type CanalNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type CidrBlocksObservation struct {

	// The GKE master authorized network config cidr block
	CidrBlock *string `json:"cidrBlock,omitempty" tf:"cidr_block,omitempty"`

	// The GKE master authorized network config cidr block dispaly name
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`
}

type CidrBlocksParameters struct {

	// The GKE master authorized network config cidr block
	// +kubebuilder:validation:Required
	CidrBlock *string `json:"cidrBlock" tf:"cidr_block,omitempty"`

	// The GKE master authorized network config cidr block dispaly name
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`
}

type CloudProviderObservation struct {
	AwsCloudProvider []AwsCloudProviderObservation `json:"awsCloudProvider,omitempty" tf:"aws_cloud_provider,omitempty"`

	AzureCloudProvider []AzureCloudProviderObservation `json:"azureCloudProvider,omitempty" tf:"azure_cloud_provider,omitempty"`

	CustomCloudProvider *string `json:"customCloudProvider,omitempty" tf:"custom_cloud_provider,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	OpenstackCloudProvider []OpenstackCloudProviderObservation `json:"openstackCloudProvider,omitempty" tf:"openstack_cloud_provider,omitempty"`

	VsphereCloudProvider []VsphereCloudProviderObservation `json:"vsphereCloudProvider,omitempty" tf:"vsphere_cloud_provider,omitempty"`
}

type CloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	AwsCloudProvider []AwsCloudProviderParameters `json:"awsCloudProvider,omitempty" tf:"aws_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	AzureCloudProvider []AzureCloudProviderParameters `json:"azureCloudProvider,omitempty" tf:"azure_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCloudProvider *string `json:"customCloudProvider,omitempty" tf:"custom_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	OpenstackCloudProvider []OpenstackCloudProviderParameters `json:"openstackCloudProvider,omitempty" tf:"openstack_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	VsphereCloudProvider []VsphereCloudProviderParameters `json:"vsphereCloudProvider,omitempty" tf:"vsphere_cloud_provider,omitempty"`
}

type ClusterAddonsObservation struct {

	// Enable GKE HTTP load balancing
	HTTPLoadBalancing *bool `json:"httpLoadBalancing,omitempty" tf:"http_load_balancing,omitempty"`

	// Enable GKE horizontal pod autoscaling
	HorizontalPodAutoscaling *bool `json:"horizontalPodAutoscaling,omitempty" tf:"horizontal_pod_autoscaling,omitempty"`

	// Enable GKE network policy config
	NetworkPolicyConfig *bool `json:"networkPolicyConfig,omitempty" tf:"network_policy_config,omitempty"`
}

type ClusterAddonsParameters struct {

	// Enable GKE HTTP load balancing
	// +kubebuilder:validation:Optional
	HTTPLoadBalancing *bool `json:"httpLoadBalancing,omitempty" tf:"http_load_balancing,omitempty"`

	// Enable GKE horizontal pod autoscaling
	// +kubebuilder:validation:Optional
	HorizontalPodAutoscaling *bool `json:"horizontalPodAutoscaling,omitempty" tf:"horizontal_pod_autoscaling,omitempty"`

	// Enable GKE network policy config
	// +kubebuilder:validation:Optional
	NetworkPolicyConfig *bool `json:"networkPolicyConfig,omitempty" tf:"network_policy_config,omitempty"`
}

type ClusterAuthEndpointObservation struct {
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type ClusterAuthEndpointParameters struct {

	// +kubebuilder:validation:Optional
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type ClusterMonitoringInputObservation struct {

	// Answers for monitor input
	Answers map[string]*string `json:"answers,omitempty" tf:"answers,omitempty"`

	// Monitoring version
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ClusterMonitoringInputParameters struct {

	// Answers for monitor input
	// +kubebuilder:validation:Optional
	Answers map[string]*string `json:"answers,omitempty" tf:"answers,omitempty"`

	// Monitoring version
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ClusterObservation struct {

	// Optional Agent Env Vars for Rancher agent
	AgentEnvVars []AgentEnvVarsObservation `json:"agentEnvVars,omitempty" tf:"agent_env_vars,omitempty"`

	AksConfig []AksConfigObservation `json:"aksConfig,omitempty" tf:"aks_config,omitempty"`

	AksConfigV2 []AksConfigV2Observation `json:"aksConfigV2,omitempty" tf:"aks_config_v2,omitempty"`

	// Annotations of the resource
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	ClusterAuthEndpoint []ClusterAuthEndpointObservation `json:"clusterAuthEndpoint,omitempty" tf:"cluster_auth_endpoint,omitempty"`

	// Cluster monitoring configuration
	ClusterMonitoringInput []ClusterMonitoringInputObservation `json:"clusterMonitoringInput,omitempty" tf:"cluster_monitoring_input,omitempty"`

	ClusterRegistrationToken []ClusterRegistrationTokenObservation `json:"clusterRegistrationToken,omitempty" tf:"cluster_registration_token,omitempty"`

	// Cluster template answers
	ClusterTemplateAnswers []ClusterTemplateAnswersObservation `json:"clusterTemplateAnswers,omitempty" tf:"cluster_template_answers,omitempty"`

	// Cluster template ID
	ClusterTemplateID *string `json:"clusterTemplateId,omitempty" tf:"cluster_template_id,omitempty"`

	// Cluster template questions
	ClusterTemplateQuestions []ClusterTemplateQuestionsObservation `json:"clusterTemplateQuestions,omitempty" tf:"cluster_template_questions,omitempty"`

	// Cluster template revision ID
	ClusterTemplateRevisionID *string `json:"clusterTemplateRevisionId,omitempty" tf:"cluster_template_revision_id,omitempty"`

	// Default pod security policy template id
	DefaultPodSecurityPolicyTemplateID *string `json:"defaultPodSecurityPolicyTemplateId,omitempty" tf:"default_pod_security_policy_template_id,omitempty"`

	DefaultProjectID *string `json:"defaultProjectId,omitempty" tf:"default_project_id,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	DesiredAgentImage *string `json:"desiredAgentImage,omitempty" tf:"desired_agent_image,omitempty"`

	DesiredAuthImage *string `json:"desiredAuthImage,omitempty" tf:"desired_auth_image,omitempty"`

	DockerRootDir *string `json:"dockerRootDir,omitempty" tf:"docker_root_dir,omitempty"`

	Driver *string `json:"driver,omitempty" tf:"driver,omitempty"`

	EksConfig []EksConfigObservation `json:"eksConfig,omitempty" tf:"eks_config,omitempty"`

	EksConfigV2 []EksConfigV2Observation `json:"eksConfigV2,omitempty" tf:"eks_config_v2,omitempty"`

	// Enable built-in cluster alerting
	EnableClusterAlerting *bool `json:"enableClusterAlerting,omitempty" tf:"enable_cluster_alerting,omitempty"`

	// Enable built-in cluster istio
	EnableClusterIstio *bool `json:"enableClusterIstio,omitempty" tf:"enable_cluster_istio,omitempty"`

	// Enable built-in cluster monitoring
	EnableClusterMonitoring *bool `json:"enableClusterMonitoring,omitempty" tf:"enable_cluster_monitoring,omitempty"`

	// Enable project network isolation
	EnableNetworkPolicy *bool `json:"enableNetworkPolicy,omitempty" tf:"enable_network_policy,omitempty"`

	FleetWorkspaceName *string `json:"fleetWorkspaceName,omitempty" tf:"fleet_workspace_name,omitempty"`

	GkeConfig []GkeConfigObservation `json:"gkeConfig,omitempty" tf:"gke_config,omitempty"`

	GkeConfigV2 []GkeConfigV2Observation `json:"gkeConfigV2,omitempty" tf:"gke_config_v2,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Is istio enabled at cluster?
	IstioEnabled *bool `json:"istioEnabled,omitempty" tf:"istio_enabled,omitempty"`

	K3SConfig []K3SConfigObservation `json:"k3sConfig,omitempty" tf:"k3s_config,omitempty"`

	// Labels of the resource
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	OkeConfig []OkeConfigObservation `json:"okeConfig,omitempty" tf:"oke_config,omitempty"`

	Rke2Config []Rke2ConfigObservation `json:"rke2Config,omitempty" tf:"rke2_config,omitempty"`

	RkeConfig []RkeConfigObservation `json:"rkeConfig,omitempty" tf:"rke_config,omitempty"`

	SystemProjectID *string `json:"systemProjectId,omitempty" tf:"system_project_id,omitempty"`

	// Windows preferred cluster
	WindowsPreferedCluster *bool `json:"windowsPreferedCluster,omitempty" tf:"windows_prefered_cluster,omitempty"`
}

type ClusterParameters struct {

	// Optional Agent Env Vars for Rancher agent
	// +kubebuilder:validation:Optional
	AgentEnvVars []AgentEnvVarsParameters `json:"agentEnvVars,omitempty" tf:"agent_env_vars,omitempty"`

	// +kubebuilder:validation:Optional
	AksConfig []AksConfigParameters `json:"aksConfig,omitempty" tf:"aks_config,omitempty"`

	// +kubebuilder:validation:Optional
	AksConfigV2 []AksConfigV2Parameters `json:"aksConfigV2,omitempty" tf:"aks_config_v2,omitempty"`

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterAuthEndpoint []ClusterAuthEndpointParameters `json:"clusterAuthEndpoint,omitempty" tf:"cluster_auth_endpoint,omitempty"`

	// Cluster monitoring configuration
	// +kubebuilder:validation:Optional
	ClusterMonitoringInput []ClusterMonitoringInputParameters `json:"clusterMonitoringInput,omitempty" tf:"cluster_monitoring_input,omitempty"`

	// Cluster template answers
	// +kubebuilder:validation:Optional
	ClusterTemplateAnswers []ClusterTemplateAnswersParameters `json:"clusterTemplateAnswers,omitempty" tf:"cluster_template_answers,omitempty"`

	// Cluster template ID
	// +kubebuilder:validation:Optional
	ClusterTemplateID *string `json:"clusterTemplateId,omitempty" tf:"cluster_template_id,omitempty"`

	// Cluster template questions
	// +kubebuilder:validation:Optional
	ClusterTemplateQuestions []ClusterTemplateQuestionsParameters `json:"clusterTemplateQuestions,omitempty" tf:"cluster_template_questions,omitempty"`

	// Cluster template revision ID
	// +kubebuilder:validation:Optional
	ClusterTemplateRevisionID *string `json:"clusterTemplateRevisionId,omitempty" tf:"cluster_template_revision_id,omitempty"`

	// Default pod security policy template id
	// +kubebuilder:validation:Optional
	DefaultPodSecurityPolicyTemplateID *string `json:"defaultPodSecurityPolicyTemplateId,omitempty" tf:"default_pod_security_policy_template_id,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredAgentImage *string `json:"desiredAgentImage,omitempty" tf:"desired_agent_image,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredAuthImage *string `json:"desiredAuthImage,omitempty" tf:"desired_auth_image,omitempty"`

	// +kubebuilder:validation:Optional
	DockerRootDir *string `json:"dockerRootDir,omitempty" tf:"docker_root_dir,omitempty"`

	// +kubebuilder:validation:Optional
	Driver *string `json:"driver,omitempty" tf:"driver,omitempty"`

	// +kubebuilder:validation:Optional
	EksConfig []EksConfigParameters `json:"eksConfig,omitempty" tf:"eks_config,omitempty"`

	// +kubebuilder:validation:Optional
	EksConfigV2 []EksConfigV2Parameters `json:"eksConfigV2,omitempty" tf:"eks_config_v2,omitempty"`

	// Enable built-in cluster alerting
	// +kubebuilder:validation:Optional
	EnableClusterAlerting *bool `json:"enableClusterAlerting,omitempty" tf:"enable_cluster_alerting,omitempty"`

	// Enable built-in cluster monitoring
	// +kubebuilder:validation:Optional
	EnableClusterMonitoring *bool `json:"enableClusterMonitoring,omitempty" tf:"enable_cluster_monitoring,omitempty"`

	// Enable project network isolation
	// +kubebuilder:validation:Optional
	EnableNetworkPolicy *bool `json:"enableNetworkPolicy,omitempty" tf:"enable_network_policy,omitempty"`

	// +kubebuilder:validation:Optional
	FleetWorkspaceName *string `json:"fleetWorkspaceName,omitempty" tf:"fleet_workspace_name,omitempty"`

	// +kubebuilder:validation:Optional
	GkeConfig []GkeConfigParameters `json:"gkeConfig,omitempty" tf:"gke_config,omitempty"`

	// +kubebuilder:validation:Optional
	GkeConfigV2 []GkeConfigV2Parameters `json:"gkeConfigV2,omitempty" tf:"gke_config_v2,omitempty"`

	// +kubebuilder:validation:Optional
	K3SConfig []K3SConfigParameters `json:"k3sConfig,omitempty" tf:"k3s_config,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	OkeConfig []OkeConfigParameters `json:"okeConfig,omitempty" tf:"oke_config,omitempty"`

	// +kubebuilder:validation:Optional
	Rke2Config []Rke2ConfigParameters `json:"rke2Config,omitempty" tf:"rke2_config,omitempty"`

	// +kubebuilder:validation:Optional
	RkeConfig []RkeConfigParameters `json:"rkeConfig,omitempty" tf:"rke_config,omitempty"`

	// Windows preferred cluster
	// +kubebuilder:validation:Optional
	WindowsPreferedCluster *bool `json:"windowsPreferedCluster,omitempty" tf:"windows_prefered_cluster,omitempty"`
}

type ClusterRegistrationTokenObservation struct {
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	Command *string `json:"command,omitempty" tf:"command,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InsecureCommand *string `json:"insecureCommand,omitempty" tf:"insecure_command,omitempty"`

	InsecureNodeCommand *string `json:"insecureNodeCommand,omitempty" tf:"insecure_node_command,omitempty"`

	InsecureWindowsNodeCommand *string `json:"insecureWindowsNodeCommand,omitempty" tf:"insecure_windows_node_command,omitempty"`

	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	ManifestURL *string `json:"manifestUrl,omitempty" tf:"manifest_url,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NodeCommand *string `json:"nodeCommand,omitempty" tf:"node_command,omitempty"`

	Token *string `json:"token,omitempty" tf:"token,omitempty"`

	WindowsNodeCommand *string `json:"windowsNodeCommand,omitempty" tf:"windows_node_command,omitempty"`
}

type ClusterRegistrationTokenParameters struct {
}

type ClusterTemplateAnswersObservation struct {

	// Cluster ID for answer
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Project ID for answer
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Key/values for answer
	Values map[string]*string `json:"values,omitempty" tf:"values,omitempty"`
}

type ClusterTemplateAnswersParameters struct {

	// Cluster ID for answer
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Project ID for answer
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Key/values for answer
	// +kubebuilder:validation:Optional
	Values map[string]*string `json:"values,omitempty" tf:"values,omitempty"`
}

type ClusterTemplateQuestionsObservation struct {

	// Default variable value
	Default *string `json:"default,omitempty" tf:"default,omitempty"`

	// Required variable
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Variable type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Variable name
	Variable *string `json:"variable,omitempty" tf:"variable,omitempty"`
}

type ClusterTemplateQuestionsParameters struct {

	// Default variable value
	// +kubebuilder:validation:Required
	Default *string `json:"default" tf:"default,omitempty"`

	// Required variable
	// +kubebuilder:validation:Optional
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Variable type
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Variable name
	// +kubebuilder:validation:Required
	Variable *string `json:"variable" tf:"variable,omitempty"`
}

type ConfigObservation struct {

	// The GKE node config disk size (Gb)
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// The GKE node config disk type
	DiskType *string `json:"diskType,omitempty" tf:"disk_type,omitempty"`

	// The GKE node config image type
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// The GKE node config labels
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The GKE node config local ssd count
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// The GKE node config machine type
	MachineType *string `json:"machineType,omitempty" tf:"machine_type,omitempty"`

	// The GKE node config oauth scopes
	OauthScopes []*string `json:"oauthScopes,omitempty" tf:"oauth_scopes,omitempty"`

	// Enable GKE node config preemptible
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`

	// The GKE node config tags
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The GKE node config taints
	Taints []TaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`
}

type ConfigParameters struct {

	// The GKE node config disk size (Gb)
	// +kubebuilder:validation:Optional
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// The GKE node config disk type
	// +kubebuilder:validation:Optional
	DiskType *string `json:"diskType,omitempty" tf:"disk_type,omitempty"`

	// The GKE node config image type
	// +kubebuilder:validation:Optional
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// The GKE node config labels
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The GKE node config local ssd count
	// +kubebuilder:validation:Optional
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// The GKE node config machine type
	// +kubebuilder:validation:Optional
	MachineType *string `json:"machineType,omitempty" tf:"machine_type,omitempty"`

	// The GKE node config oauth scopes
	// +kubebuilder:validation:Optional
	OauthScopes []*string `json:"oauthScopes,omitempty" tf:"oauth_scopes,omitempty"`

	// Enable GKE node config preemptible
	// +kubebuilder:validation:Optional
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`

	// The GKE node config tags
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The GKE node config taints
	// +kubebuilder:validation:Optional
	Taints []TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`
}

type ConfigurationObservation struct {
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`

	MaxBackup *float64 `json:"maxBackup,omitempty" tf:"max_backup,omitempty"`

	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type ConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBackup *float64 `json:"maxBackup,omitempty" tf:"max_backup,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type DNSObservation struct {

	// Linear Autoscaler Params
	LinearAutoscalerParams []LinearAutoscalerParamsObservation `json:"linearAutoscalerParams,omitempty" tf:"linear_autoscaler_params,omitempty"`

	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// Nodelocal dns
	Nodelocal []NodelocalObservation `json:"nodelocal,omitempty" tf:"nodelocal,omitempty"`

	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	ReverseCidrs []*string `json:"reverseCidrs,omitempty" tf:"reverse_cidrs,omitempty"`

	// DNS service tolerations
	Tolerations []TolerationsObservation `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update deployment strategy
	UpdateStrategy []UpdateStrategyObservation `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`

	UpstreamNameservers []*string `json:"upstreamNameservers,omitempty" tf:"upstream_nameservers,omitempty"`
}

type DNSParameters struct {

	// Linear Autoscaler Params
	// +kubebuilder:validation:Optional
	LinearAutoscalerParams []LinearAutoscalerParamsParameters `json:"linearAutoscalerParams,omitempty" tf:"linear_autoscaler_params,omitempty"`

	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// Nodelocal dns
	// +kubebuilder:validation:Optional
	Nodelocal []NodelocalParameters `json:"nodelocal,omitempty" tf:"nodelocal,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	ReverseCidrs []*string `json:"reverseCidrs,omitempty" tf:"reverse_cidrs,omitempty"`

	// DNS service tolerations
	// +kubebuilder:validation:Optional
	Tolerations []TolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update deployment strategy
	// +kubebuilder:validation:Optional
	UpdateStrategy []UpdateStrategyParameters `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	UpstreamNameservers []*string `json:"upstreamNameservers,omitempty" tf:"upstream_nameservers,omitempty"`
}

type DiskObservation struct {
	ScsiControllerType *string `json:"scsiControllerType,omitempty" tf:"scsi_controller_type,omitempty"`
}

type DiskParameters struct {

	// +kubebuilder:validation:Optional
	ScsiControllerType *string `json:"scsiControllerType,omitempty" tf:"scsi_controller_type,omitempty"`
}

type DrainInputObservation struct {
	DeleteLocalData *bool `json:"deleteLocalData,omitempty" tf:"delete_local_data,omitempty"`

	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type DrainInputParameters struct {

	// +kubebuilder:validation:Optional
	DeleteLocalData *bool `json:"deleteLocalData,omitempty" tf:"delete_local_data,omitempty"`

	// +kubebuilder:validation:Optional
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type EcrCredentialPluginObservation struct {
	AwsAccessKeyID *string `json:"awsAccessKeyId,omitempty" tf:"aws_access_key_id,omitempty"`
}

type EcrCredentialPluginParameters struct {

	// +kubebuilder:validation:Optional
	AwsAccessKeyID *string `json:"awsAccessKeyId,omitempty" tf:"aws_access_key_id,omitempty"`

	// +kubebuilder:validation:Optional
	AwsSecretAccessKeySecretRef *v1.SecretKeySelector `json:"awsSecretAccessKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	AwsSessionTokenSecretRef *v1.SecretKeySelector `json:"awsSessionTokenSecretRef,omitempty" tf:"-"`
}

type EksConfigObservation struct {

	// A custom AMI ID to use for the worker nodes instead of the default
	AMI *string `json:"ami,omitempty" tf:"ami,omitempty"`

	// Associate public ip EKS worker nodes
	AssociateWorkerNodePublicIP *bool `json:"associateWorkerNodePublicIp,omitempty" tf:"associate_worker_node_public_ip,omitempty"`

	// The desired number of worker nodes
	DesiredNodes *float64 `json:"desiredNodes,omitempty" tf:"desired_nodes,omitempty"`

	// Enables EBS encryption of worker nodes
	EBSEncryption *bool `json:"ebsEncryption,omitempty" tf:"ebs_encryption,omitempty"`

	// The type of machine to use for worker nodes
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// Allow user to specify key name to use
	KeyPairName *string `json:"keyPairName,omitempty" tf:"key_pair_name,omitempty"`

	// The kubernetes master version
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The maximum number of worker nodes
	MaximumNodes *float64 `json:"maximumNodes,omitempty" tf:"maximum_nodes,omitempty"`

	// The minimum number of worker nodes
	MinimumNodes *float64 `json:"minimumNodes,omitempty" tf:"minimum_nodes,omitempty"`

	// The volume size for each node
	NodeVolumeSize *float64 `json:"nodeVolumeSize,omitempty" tf:"node_volume_size,omitempty"`

	// The AWS Region to create the EKS cluster in
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// List of security groups to use for the cluster
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// The service role to use to perform the cluster operations in AWS
	ServiceRole *string `json:"serviceRole,omitempty" tf:"service_role,omitempty"`

	// List of subnets in the virtual network to use
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// Pass user-data to the nodes to perform automated configuration tasks
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The name of the virtual network to use
	VirtualNetwork *string `json:"virtualNetwork,omitempty" tf:"virtual_network,omitempty"`
}

type EksConfigParameters struct {

	// A custom AMI ID to use for the worker nodes instead of the default
	// +kubebuilder:validation:Optional
	AMI *string `json:"ami,omitempty" tf:"ami,omitempty"`

	// The AWS Client ID to use
	// +kubebuilder:validation:Required
	AccessKeySecretRef v1.SecretKeySelector `json:"accessKeySecretRef" tf:"-"`

	// Associate public ip EKS worker nodes
	// +kubebuilder:validation:Optional
	AssociateWorkerNodePublicIP *bool `json:"associateWorkerNodePublicIp,omitempty" tf:"associate_worker_node_public_ip,omitempty"`

	// The desired number of worker nodes
	// +kubebuilder:validation:Optional
	DesiredNodes *float64 `json:"desiredNodes,omitempty" tf:"desired_nodes,omitempty"`

	// Enables EBS encryption of worker nodes
	// +kubebuilder:validation:Optional
	EBSEncryption *bool `json:"ebsEncryption,omitempty" tf:"ebs_encryption,omitempty"`

	// The type of machine to use for worker nodes
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// Allow user to specify key name to use
	// +kubebuilder:validation:Optional
	KeyPairName *string `json:"keyPairName,omitempty" tf:"key_pair_name,omitempty"`

	// The kubernetes master version
	// +kubebuilder:validation:Required
	KubernetesVersion *string `json:"kubernetesVersion" tf:"kubernetes_version,omitempty"`

	// The maximum number of worker nodes
	// +kubebuilder:validation:Optional
	MaximumNodes *float64 `json:"maximumNodes,omitempty" tf:"maximum_nodes,omitempty"`

	// The minimum number of worker nodes
	// +kubebuilder:validation:Optional
	MinimumNodes *float64 `json:"minimumNodes,omitempty" tf:"minimum_nodes,omitempty"`

	// The volume size for each node
	// +kubebuilder:validation:Optional
	NodeVolumeSize *float64 `json:"nodeVolumeSize,omitempty" tf:"node_volume_size,omitempty"`

	// The AWS Region to create the EKS cluster in
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The AWS Client Secret associated with the Client ID
	// +kubebuilder:validation:Required
	SecretKeySecretRef v1.SecretKeySelector `json:"secretKeySecretRef" tf:"-"`

	// List of security groups to use for the cluster
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// The service role to use to perform the cluster operations in AWS
	// +kubebuilder:validation:Optional
	ServiceRole *string `json:"serviceRole,omitempty" tf:"service_role,omitempty"`

	// A session token to use with the client key and secret if applicable
	// +kubebuilder:validation:Optional
	SessionTokenSecretRef *v1.SecretKeySelector `json:"sessionTokenSecretRef,omitempty" tf:"-"`

	// List of subnets in the virtual network to use
	// +kubebuilder:validation:Optional
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// Pass user-data to the nodes to perform automated configuration tasks
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The name of the virtual network to use
	// +kubebuilder:validation:Optional
	VirtualNetwork *string `json:"virtualNetwork,omitempty" tf:"virtual_network,omitempty"`
}

type EksConfigV2Observation struct {

	// The AWS Cloud Credential ID to use
	CloudCredentialID *string `json:"cloudCredentialId,omitempty" tf:"cloud_credential_id,omitempty"`

	// Is EKS cluster imported?
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// The AWS kms key to use
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// The kubernetes master version
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The AWS logging types
	LoggingTypes []*string `json:"loggingTypes,omitempty" tf:"logging_types,omitempty"`

	// The EKS cluster name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The AWS node groups to use
	NodeGroups []NodeGroupsObservation `json:"nodeGroups,omitempty" tf:"node_groups,omitempty"`

	// The EKS cluster has private access
	PrivateAccess *bool `json:"privateAccess,omitempty" tf:"private_access,omitempty"`

	// The EKS cluster has public access
	PublicAccess *bool `json:"publicAccess,omitempty" tf:"public_access,omitempty"`

	// The EKS cluster public access sources
	PublicAccessSources []*string `json:"publicAccessSources,omitempty" tf:"public_access_sources,omitempty"`

	// The AWS Region to create the EKS cluster in
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Enable EKS cluster secret encryption
	SecretsEncryption *bool `json:"secretsEncryption,omitempty" tf:"secrets_encryption,omitempty"`

	// List of security groups to use for the cluster
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// The AWS service role to use
	ServiceRole *string `json:"serviceRole,omitempty" tf:"service_role,omitempty"`

	// List of subnets in the virtual network to use
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// The EKS cluster tags
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type EksConfigV2Parameters struct {

	// The AWS Cloud Credential ID to use
	// +kubebuilder:validation:Required
	CloudCredentialID *string `json:"cloudCredentialId" tf:"cloud_credential_id,omitempty"`

	// Is EKS cluster imported?
	// +kubebuilder:validation:Optional
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// The AWS kms key to use
	// +kubebuilder:validation:Optional
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// The kubernetes master version
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The AWS logging types
	// +kubebuilder:validation:Optional
	LoggingTypes []*string `json:"loggingTypes,omitempty" tf:"logging_types,omitempty"`

	// The EKS cluster name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The AWS node groups to use
	// +kubebuilder:validation:Optional
	NodeGroups []NodeGroupsParameters `json:"nodeGroups,omitempty" tf:"node_groups,omitempty"`

	// The EKS cluster has private access
	// +kubebuilder:validation:Optional
	PrivateAccess *bool `json:"privateAccess,omitempty" tf:"private_access,omitempty"`

	// The EKS cluster has public access
	// +kubebuilder:validation:Optional
	PublicAccess *bool `json:"publicAccess,omitempty" tf:"public_access,omitempty"`

	// The EKS cluster public access sources
	// +kubebuilder:validation:Optional
	PublicAccessSources []*string `json:"publicAccessSources,omitempty" tf:"public_access_sources,omitempty"`

	// The AWS Region to create the EKS cluster in
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Enable EKS cluster secret encryption
	// +kubebuilder:validation:Optional
	SecretsEncryption *bool `json:"secretsEncryption,omitempty" tf:"secrets_encryption,omitempty"`

	// List of security groups to use for the cluster
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// The AWS service role to use
	// +kubebuilder:validation:Optional
	ServiceRole *string `json:"serviceRole,omitempty" tf:"service_role,omitempty"`

	// List of subnets in the virtual network to use
	// +kubebuilder:validation:Optional
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// The EKS cluster tags
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type EtcdObservation struct {
	BackupConfig []BackupConfigObservation `json:"backupConfig,omitempty" tf:"backup_config,omitempty"`

	CACert *string `json:"caCert,omitempty" tf:"ca_cert,omitempty"`

	Creation *string `json:"creation,omitempty" tf:"creation,omitempty"`

	ExternalUrls []*string `json:"externalUrls,omitempty" tf:"external_urls,omitempty"`

	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	GID *float64 `json:"gid,omitempty" tf:"gid,omitempty"`

	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	Retention *string `json:"retention,omitempty" tf:"retention,omitempty"`

	Snapshot *bool `json:"snapshot,omitempty" tf:"snapshot,omitempty"`

	UID *float64 `json:"uid,omitempty" tf:"uid,omitempty"`
}

type EtcdParameters struct {

	// +kubebuilder:validation:Optional
	BackupConfig []BackupConfigParameters `json:"backupConfig,omitempty" tf:"backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	CACert *string `json:"caCert,omitempty" tf:"ca_cert,omitempty"`

	// +kubebuilder:validation:Optional
	CertSecretRef *v1.SecretKeySelector `json:"certSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Creation *string `json:"creation,omitempty" tf:"creation,omitempty"`

	// +kubebuilder:validation:Optional
	ExternalUrls []*string `json:"externalUrls,omitempty" tf:"external_urls,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	GID *float64 `json:"gid,omitempty" tf:"gid,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	KeySecretRef *v1.SecretKeySelector `json:"keySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *string `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	Snapshot *bool `json:"snapshot,omitempty" tf:"snapshot,omitempty"`

	// +kubebuilder:validation:Optional
	UID *float64 `json:"uid,omitempty" tf:"uid,omitempty"`
}

type EventRateLimitObservation struct {
	Configuration *string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type EventRateLimitParameters struct {

	// +kubebuilder:validation:Optional
	Configuration *string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type FlannelNetworkProviderObservation struct {
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type FlannelNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type GkeConfigObservation struct {

	// The IP address range of the container pods
	ClusterIPv4Cidr *string `json:"clusterIpv4Cidr,omitempty" tf:"cluster_ipv4_cidr,omitempty"`

	// An optional description of this cluster
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Size of the disk attached to each node
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// Type of the disk attached to each node
	DiskType *string `json:"diskType,omitempty" tf:"disk_type,omitempty"`

	// To enable kubernetes alpha feature
	EnableAlphaFeature *bool `json:"enableAlphaFeature,omitempty" tf:"enable_alpha_feature,omitempty"`

	// Specifies whether the node auto-repair is enabled for the node pool
	EnableAutoRepair *bool `json:"enableAutoRepair,omitempty" tf:"enable_auto_repair,omitempty"`

	// Specifies whether node auto-upgrade is enabled for the node pool
	EnableAutoUpgrade *bool `json:"enableAutoUpgrade,omitempty" tf:"enable_auto_upgrade,omitempty"`

	// Enable http load balancing for the cluster
	EnableHTTPLoadBalancing *bool `json:"enableHttpLoadBalancing,omitempty" tf:"enable_http_load_balancing,omitempty"`

	// Enable horizontal pod autoscaling for the cluster
	EnableHorizontalPodAutoscaling *bool `json:"enableHorizontalPodAutoscaling,omitempty" tf:"enable_horizontal_pod_autoscaling,omitempty"`

	// Whether to enable the kubernetes dashboard
	EnableKubernetesDashboard *bool `json:"enableKubernetesDashboard,omitempty" tf:"enable_kubernetes_dashboard,omitempty"`

	// Whether to enable legacy abac on the cluster
	EnableLegacyAbac *bool `json:"enableLegacyAbac,omitempty" tf:"enable_legacy_abac,omitempty"`

	// Whether or not master authorized network is enabled
	EnableMasterAuthorizedNetwork *bool `json:"enableMasterAuthorizedNetwork,omitempty" tf:"enable_master_authorized_network,omitempty"`

	// Enable network policy config for the cluster
	EnableNetworkPolicyConfig *bool `json:"enableNetworkPolicyConfig,omitempty" tf:"enable_network_policy_config,omitempty"`

	// Enable nodepool autoscaling
	EnableNodepoolAutoscaling *bool `json:"enableNodepoolAutoscaling,omitempty" tf:"enable_nodepool_autoscaling,omitempty"`

	// Whether the master's internal IP address is used as the cluster endpoint
	EnablePrivateEndpoint *bool `json:"enablePrivateEndpoint,omitempty" tf:"enable_private_endpoint,omitempty"`

	// Whether nodes have internal IP address only
	EnablePrivateNodes *bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`

	// Enable stackdriver logging
	EnableStackdriverLogging *bool `json:"enableStackdriverLogging,omitempty" tf:"enable_stackdriver_logging,omitempty"`

	// Enable stackdriver monitoring
	EnableStackdriverMonitoring *bool `json:"enableStackdriverMonitoring,omitempty" tf:"enable_stackdriver_monitoring,omitempty"`

	// The IP address range for the cluster pod IPs
	IPPolicyClusterIPv4CidrBlock *string `json:"ipPolicyClusterIpv4CidrBlock,omitempty" tf:"ip_policy_cluster_ipv4_cidr_block,omitempty"`

	// The name of the secondary range to be used for the cluster CIDR block
	IPPolicyClusterSecondaryRangeName *string `json:"ipPolicyClusterSecondaryRangeName,omitempty" tf:"ip_policy_cluster_secondary_range_name,omitempty"`

	// Whether a new subnetwork will be created automatically for the cluster
	IPPolicyCreateSubnetwork *bool `json:"ipPolicyCreateSubnetwork,omitempty" tf:"ip_policy_create_subnetwork,omitempty"`

	// The IP address range of the instance IPs in this cluster
	IPPolicyNodeIPv4CidrBlock *string `json:"ipPolicyNodeIpv4CidrBlock,omitempty" tf:"ip_policy_node_ipv4_cidr_block,omitempty"`

	// The IP address range of the services IPs in this cluster
	IPPolicyServicesIPv4CidrBlock *string `json:"ipPolicyServicesIpv4CidrBlock,omitempty" tf:"ip_policy_services_ipv4_cidr_block,omitempty"`

	// The name of the secondary range to be used for the services CIDR block
	IPPolicyServicesSecondaryRangeName *string `json:"ipPolicyServicesSecondaryRangeName,omitempty" tf:"ip_policy_services_secondary_range_name,omitempty"`

	// A custom subnetwork name to be used if createSubnetwork is true
	IPPolicySubnetworkName *string `json:"ipPolicySubnetworkName,omitempty" tf:"ip_policy_subnetwork_name,omitempty"`

	// The image to use for the worker nodes
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// Issue a client certificate
	IssueClientCertificate *bool `json:"issueClientCertificate,omitempty" tf:"issue_client_certificate,omitempty"`

	// Enable the kubernetes dashboard
	KubernetesDashboard *bool `json:"kubernetesDashboard,omitempty" tf:"kubernetes_dashboard,omitempty"`

	// The map of Kubernetes labels (key/value pairs) to be applied to each node
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The number of local SSD disks to be attached to the node
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// Locations to use for the cluster
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`

	// The machine type to use for the worker nodes
	MachineType *string `json:"machineType,omitempty" tf:"machine_type,omitempty"`

	// When to performance updates on the nodes, in 24-hour time
	MaintenanceWindow *string `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`

	// Define up to 10 external networks that could access Kubernetes master through HTTPS
	MasterAuthorizedNetworkCidrBlocks []*string `json:"masterAuthorizedNetworkCidrBlocks,omitempty" tf:"master_authorized_network_cidr_blocks,omitempty"`

	// The IP range in CIDR notation to use for the hosted master network
	MasterIPv4CidrBlock *string `json:"masterIpv4CidrBlock,omitempty" tf:"master_ipv4_cidr_block,omitempty"`

	// The kubernetes master version
	MasterVersion *string `json:"masterVersion,omitempty" tf:"master_version,omitempty"`

	// Maximum number of nodes in the NodePool. Must be >= minNodeCount. There has to enough quota to scale up the cluster
	MaxNodeCount *float64 `json:"maxNodeCount,omitempty" tf:"max_node_count,omitempty"`

	// Minimmum number of nodes in the NodePool. Must be >= 1 and <= maxNodeCount
	MinNodeCount *float64 `json:"minNodeCount,omitempty" tf:"min_node_count,omitempty"`

	// The network to use for the cluster
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// The number of nodes to create in this cluster
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// The ID of the cluster node pool
	NodePool *string `json:"nodePool,omitempty" tf:"node_pool,omitempty"`

	// The version of kubernetes to use on the nodes
	NodeVersion *string `json:"nodeVersion,omitempty" tf:"node_version,omitempty"`

	// The set of Google API scopes to be made available on all of the node VMs under the default service account
	OauthScopes []*string `json:"oauthScopes,omitempty" tf:"oauth_scopes,omitempty"`

	// Whether the nodes are created as preemptible VM instances
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`

	// The ID of your project to use when creating a cluster
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The region to launch the cluster. Region or zone should be used
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The map of Kubernetes labels (key/value pairs) to be applied to each cluster
	ResourceLabels map[string]*string `json:"resourceLabels,omitempty" tf:"resource_labels,omitempty"`

	// The Google Cloud Platform Service Account to be used by the node VMs
	ServiceAccount *string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`

	// The sub-network to use for the cluster
	SubNetwork *string `json:"subNetwork,omitempty" tf:"sub_network,omitempty"`

	// List of kubernetes taints to be applied to each node
	Taints []*string `json:"taints,omitempty" tf:"taints,omitempty"`

	// Whether alias IPs will be used for pod IPs in the cluster
	UseIPAliases *bool `json:"useIpAliases,omitempty" tf:"use_ip_aliases,omitempty"`

	// The zone to launch the cluster. Zone or region should be used
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type GkeConfigParameters struct {

	// The IP address range of the container pods
	// +kubebuilder:validation:Required
	ClusterIPv4Cidr *string `json:"clusterIpv4Cidr" tf:"cluster_ipv4_cidr,omitempty"`

	// The contents of the GC credential file
	// +kubebuilder:validation:Required
	CredentialSecretRef v1.SecretKeySelector `json:"credentialSecretRef" tf:"-"`

	// An optional description of this cluster
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Size of the disk attached to each node
	// +kubebuilder:validation:Optional
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// Type of the disk attached to each node
	// +kubebuilder:validation:Required
	DiskType *string `json:"diskType" tf:"disk_type,omitempty"`

	// To enable kubernetes alpha feature
	// +kubebuilder:validation:Optional
	EnableAlphaFeature *bool `json:"enableAlphaFeature,omitempty" tf:"enable_alpha_feature,omitempty"`

	// Specifies whether the node auto-repair is enabled for the node pool
	// +kubebuilder:validation:Optional
	EnableAutoRepair *bool `json:"enableAutoRepair,omitempty" tf:"enable_auto_repair,omitempty"`

	// Specifies whether node auto-upgrade is enabled for the node pool
	// +kubebuilder:validation:Optional
	EnableAutoUpgrade *bool `json:"enableAutoUpgrade,omitempty" tf:"enable_auto_upgrade,omitempty"`

	// Enable http load balancing for the cluster
	// +kubebuilder:validation:Optional
	EnableHTTPLoadBalancing *bool `json:"enableHttpLoadBalancing,omitempty" tf:"enable_http_load_balancing,omitempty"`

	// Enable horizontal pod autoscaling for the cluster
	// +kubebuilder:validation:Optional
	EnableHorizontalPodAutoscaling *bool `json:"enableHorizontalPodAutoscaling,omitempty" tf:"enable_horizontal_pod_autoscaling,omitempty"`

	// Whether to enable the kubernetes dashboard
	// +kubebuilder:validation:Optional
	EnableKubernetesDashboard *bool `json:"enableKubernetesDashboard,omitempty" tf:"enable_kubernetes_dashboard,omitempty"`

	// Whether to enable legacy abac on the cluster
	// +kubebuilder:validation:Optional
	EnableLegacyAbac *bool `json:"enableLegacyAbac,omitempty" tf:"enable_legacy_abac,omitempty"`

	// Whether or not master authorized network is enabled
	// +kubebuilder:validation:Optional
	EnableMasterAuthorizedNetwork *bool `json:"enableMasterAuthorizedNetwork,omitempty" tf:"enable_master_authorized_network,omitempty"`

	// Enable network policy config for the cluster
	// +kubebuilder:validation:Optional
	EnableNetworkPolicyConfig *bool `json:"enableNetworkPolicyConfig,omitempty" tf:"enable_network_policy_config,omitempty"`

	// Enable nodepool autoscaling
	// +kubebuilder:validation:Optional
	EnableNodepoolAutoscaling *bool `json:"enableNodepoolAutoscaling,omitempty" tf:"enable_nodepool_autoscaling,omitempty"`

	// Whether the master's internal IP address is used as the cluster endpoint
	// +kubebuilder:validation:Optional
	EnablePrivateEndpoint *bool `json:"enablePrivateEndpoint,omitempty" tf:"enable_private_endpoint,omitempty"`

	// Whether nodes have internal IP address only
	// +kubebuilder:validation:Optional
	EnablePrivateNodes *bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`

	// Enable stackdriver logging
	// +kubebuilder:validation:Optional
	EnableStackdriverLogging *bool `json:"enableStackdriverLogging,omitempty" tf:"enable_stackdriver_logging,omitempty"`

	// Enable stackdriver monitoring
	// +kubebuilder:validation:Optional
	EnableStackdriverMonitoring *bool `json:"enableStackdriverMonitoring,omitempty" tf:"enable_stackdriver_monitoring,omitempty"`

	// The IP address range for the cluster pod IPs
	// +kubebuilder:validation:Required
	IPPolicyClusterIPv4CidrBlock *string `json:"ipPolicyClusterIpv4CidrBlock" tf:"ip_policy_cluster_ipv4_cidr_block,omitempty"`

	// The name of the secondary range to be used for the cluster CIDR block
	// +kubebuilder:validation:Required
	IPPolicyClusterSecondaryRangeName *string `json:"ipPolicyClusterSecondaryRangeName" tf:"ip_policy_cluster_secondary_range_name,omitempty"`

	// Whether a new subnetwork will be created automatically for the cluster
	// +kubebuilder:validation:Optional
	IPPolicyCreateSubnetwork *bool `json:"ipPolicyCreateSubnetwork,omitempty" tf:"ip_policy_create_subnetwork,omitempty"`

	// The IP address range of the instance IPs in this cluster
	// +kubebuilder:validation:Required
	IPPolicyNodeIPv4CidrBlock *string `json:"ipPolicyNodeIpv4CidrBlock" tf:"ip_policy_node_ipv4_cidr_block,omitempty"`

	// The IP address range of the services IPs in this cluster
	// +kubebuilder:validation:Required
	IPPolicyServicesIPv4CidrBlock *string `json:"ipPolicyServicesIpv4CidrBlock" tf:"ip_policy_services_ipv4_cidr_block,omitempty"`

	// The name of the secondary range to be used for the services CIDR block
	// +kubebuilder:validation:Required
	IPPolicyServicesSecondaryRangeName *string `json:"ipPolicyServicesSecondaryRangeName" tf:"ip_policy_services_secondary_range_name,omitempty"`

	// A custom subnetwork name to be used if createSubnetwork is true
	// +kubebuilder:validation:Required
	IPPolicySubnetworkName *string `json:"ipPolicySubnetworkName" tf:"ip_policy_subnetwork_name,omitempty"`

	// The image to use for the worker nodes
	// +kubebuilder:validation:Required
	ImageType *string `json:"imageType" tf:"image_type,omitempty"`

	// Issue a client certificate
	// +kubebuilder:validation:Optional
	IssueClientCertificate *bool `json:"issueClientCertificate,omitempty" tf:"issue_client_certificate,omitempty"`

	// Enable the kubernetes dashboard
	// +kubebuilder:validation:Optional
	KubernetesDashboard *bool `json:"kubernetesDashboard,omitempty" tf:"kubernetes_dashboard,omitempty"`

	// The map of Kubernetes labels (key/value pairs) to be applied to each node
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The number of local SSD disks to be attached to the node
	// +kubebuilder:validation:Optional
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// Locations to use for the cluster
	// +kubebuilder:validation:Required
	Locations []*string `json:"locations" tf:"locations,omitempty"`

	// The machine type to use for the worker nodes
	// +kubebuilder:validation:Required
	MachineType *string `json:"machineType" tf:"machine_type,omitempty"`

	// When to performance updates on the nodes, in 24-hour time
	// +kubebuilder:validation:Required
	MaintenanceWindow *string `json:"maintenanceWindow" tf:"maintenance_window,omitempty"`

	// Define up to 10 external networks that could access Kubernetes master through HTTPS
	// +kubebuilder:validation:Optional
	MasterAuthorizedNetworkCidrBlocks []*string `json:"masterAuthorizedNetworkCidrBlocks,omitempty" tf:"master_authorized_network_cidr_blocks,omitempty"`

	// The IP range in CIDR notation to use for the hosted master network
	// +kubebuilder:validation:Required
	MasterIPv4CidrBlock *string `json:"masterIpv4CidrBlock" tf:"master_ipv4_cidr_block,omitempty"`

	// The kubernetes master version
	// +kubebuilder:validation:Required
	MasterVersion *string `json:"masterVersion" tf:"master_version,omitempty"`

	// Maximum number of nodes in the NodePool. Must be >= minNodeCount. There has to enough quota to scale up the cluster
	// +kubebuilder:validation:Optional
	MaxNodeCount *float64 `json:"maxNodeCount,omitempty" tf:"max_node_count,omitempty"`

	// Minimmum number of nodes in the NodePool. Must be >= 1 and <= maxNodeCount
	// +kubebuilder:validation:Optional
	MinNodeCount *float64 `json:"minNodeCount,omitempty" tf:"min_node_count,omitempty"`

	// The network to use for the cluster
	// +kubebuilder:validation:Required
	Network *string `json:"network" tf:"network,omitempty"`

	// The number of nodes to create in this cluster
	// +kubebuilder:validation:Optional
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// The ID of the cluster node pool
	// +kubebuilder:validation:Required
	NodePool *string `json:"nodePool" tf:"node_pool,omitempty"`

	// The version of kubernetes to use on the nodes
	// +kubebuilder:validation:Required
	NodeVersion *string `json:"nodeVersion" tf:"node_version,omitempty"`

	// The set of Google API scopes to be made available on all of the node VMs under the default service account
	// +kubebuilder:validation:Required
	OauthScopes []*string `json:"oauthScopes" tf:"oauth_scopes,omitempty"`

	// Whether the nodes are created as preemptible VM instances
	// +kubebuilder:validation:Optional
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`

	// The ID of your project to use when creating a cluster
	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`

	// The region to launch the cluster. Region or zone should be used
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The map of Kubernetes labels (key/value pairs) to be applied to each cluster
	// +kubebuilder:validation:Optional
	ResourceLabels map[string]*string `json:"resourceLabels,omitempty" tf:"resource_labels,omitempty"`

	// The Google Cloud Platform Service Account to be used by the node VMs
	// +kubebuilder:validation:Required
	ServiceAccount *string `json:"serviceAccount" tf:"service_account,omitempty"`

	// The sub-network to use for the cluster
	// +kubebuilder:validation:Required
	SubNetwork *string `json:"subNetwork" tf:"sub_network,omitempty"`

	// List of kubernetes taints to be applied to each node
	// +kubebuilder:validation:Optional
	Taints []*string `json:"taints,omitempty" tf:"taints,omitempty"`

	// Whether alias IPs will be used for pod IPs in the cluster
	// +kubebuilder:validation:Optional
	UseIPAliases *bool `json:"useIpAliases,omitempty" tf:"use_ip_aliases,omitempty"`

	// The zone to launch the cluster. Zone or region should be used
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type GkeConfigV2NodePoolsObservation struct {

	// The GKE node pool config autoscaling
	Autoscaling []AutoscalingObservation `json:"autoscaling,omitempty" tf:"autoscaling,omitempty"`

	// The GKE node pool node config
	Config []ConfigObservation `json:"config,omitempty" tf:"config,omitempty"`

	// The GKE node pool config initial node count
	InitialNodeCount *float64 `json:"initialNodeCount,omitempty" tf:"initial_node_count,omitempty"`

	// The GKE node pool config management
	Management []ManagementObservation `json:"management,omitempty" tf:"management,omitempty"`

	// The GKE node pool config max pods constraint
	MaxPodsConstraint *float64 `json:"maxPodsConstraint,omitempty" tf:"max_pods_constraint,omitempty"`

	// The GKE node pool config name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The GKE node pool config version
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type GkeConfigV2NodePoolsParameters struct {

	// The GKE node pool config autoscaling
	// +kubebuilder:validation:Optional
	Autoscaling []AutoscalingParameters `json:"autoscaling,omitempty" tf:"autoscaling,omitempty"`

	// The GKE node pool node config
	// +kubebuilder:validation:Optional
	Config []ConfigParameters `json:"config,omitempty" tf:"config,omitempty"`

	// The GKE node pool config initial node count
	// +kubebuilder:validation:Required
	InitialNodeCount *float64 `json:"initialNodeCount" tf:"initial_node_count,omitempty"`

	// The GKE node pool config management
	// +kubebuilder:validation:Optional
	Management []ManagementParameters `json:"management,omitempty" tf:"management,omitempty"`

	// The GKE node pool config max pods constraint
	// +kubebuilder:validation:Optional
	MaxPodsConstraint *float64 `json:"maxPodsConstraint,omitempty" tf:"max_pods_constraint,omitempty"`

	// The GKE node pool config name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The GKE node pool config version
	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type GkeConfigV2Observation struct {

	// The GKE cluster addons
	ClusterAddons []ClusterAddonsObservation `json:"clusterAddons,omitempty" tf:"cluster_addons,omitempty"`

	// The GKE ip v4 cidr block
	ClusterIPv4CidrBlock *string `json:"clusterIpv4CidrBlock,omitempty" tf:"cluster_ipv4_cidr_block,omitempty"`

	// The GKE cluster description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Enable Kubernetes alpha
	EnableKubernetesAlpha *bool `json:"enableKubernetesAlpha,omitempty" tf:"enable_kubernetes_alpha,omitempty"`

	// The GKE ip allocation policy
	IPAllocationPolicy []IPAllocationPolicyObservation `json:"ipAllocationPolicy,omitempty" tf:"ip_allocation_policy,omitempty"`

	// Is GKE cluster imported?
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// The kubernetes master version
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The GKE cluster labels
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The GKE cluster locations
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`

	// The GKE cluster logging service
	LoggingService *string `json:"loggingService,omitempty" tf:"logging_service,omitempty"`

	// The GKE cluster maintenance window
	MaintenanceWindow *string `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`

	// The GKE cluster master authorized networks config
	MasterAuthorizedNetworksConfig []MasterAuthorizedNetworksConfigObservation `json:"masterAuthorizedNetworksConfig,omitempty" tf:"master_authorized_networks_config,omitempty"`

	// The GKE cluster monitoring service
	MonitoringService *string `json:"monitoringService,omitempty" tf:"monitoring_service,omitempty"`

	// The GKE cluster name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The GKE cluster network
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Is GKE cluster network policy enabled?
	NetworkPolicyEnabled *bool `json:"networkPolicyEnabled,omitempty" tf:"network_policy_enabled,omitempty"`

	// The GKE cluster node pools
	NodePools []GkeConfigV2NodePoolsObservation `json:"nodePools,omitempty" tf:"node_pools,omitempty"`

	// The GKE private cluster config
	PrivateClusterConfig []PrivateClusterConfigObservation `json:"privateClusterConfig,omitempty" tf:"private_cluster_config,omitempty"`

	// The GKE project id
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The GKE cluster region. Required if `zone` is empty
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The GKE cluster subnetwork
	Subnetwork *string `json:"subnetwork,omitempty" tf:"subnetwork,omitempty"`

	// The GKE cluster zone. Required if `region` is empty
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type GkeConfigV2Parameters struct {

	// The GKE cluster addons
	// +kubebuilder:validation:Optional
	ClusterAddons []ClusterAddonsParameters `json:"clusterAddons,omitempty" tf:"cluster_addons,omitempty"`

	// The GKE ip v4 cidr block
	// +kubebuilder:validation:Optional
	ClusterIPv4CidrBlock *string `json:"clusterIpv4CidrBlock,omitempty" tf:"cluster_ipv4_cidr_block,omitempty"`

	// The GKE cluster description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Enable Kubernetes alpha
	// +kubebuilder:validation:Optional
	EnableKubernetesAlpha *bool `json:"enableKubernetesAlpha,omitempty" tf:"enable_kubernetes_alpha,omitempty"`

	// Google credential secret
	// +kubebuilder:validation:Required
	GoogleCredentialSecretSecretRef v1.SecretKeySelector `json:"googleCredentialSecretSecretRef" tf:"-"`

	// The GKE ip allocation policy
	// +kubebuilder:validation:Optional
	IPAllocationPolicy []IPAllocationPolicyParameters `json:"ipAllocationPolicy,omitempty" tf:"ip_allocation_policy,omitempty"`

	// Is GKE cluster imported?
	// +kubebuilder:validation:Optional
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// The kubernetes master version
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The GKE cluster labels
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The GKE cluster locations
	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`

	// The GKE cluster logging service
	// +kubebuilder:validation:Optional
	LoggingService *string `json:"loggingService,omitempty" tf:"logging_service,omitempty"`

	// The GKE cluster maintenance window
	// +kubebuilder:validation:Optional
	MaintenanceWindow *string `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`

	// The GKE cluster master authorized networks config
	// +kubebuilder:validation:Optional
	MasterAuthorizedNetworksConfig []MasterAuthorizedNetworksConfigParameters `json:"masterAuthorizedNetworksConfig,omitempty" tf:"master_authorized_networks_config,omitempty"`

	// The GKE cluster monitoring service
	// +kubebuilder:validation:Optional
	MonitoringService *string `json:"monitoringService,omitempty" tf:"monitoring_service,omitempty"`

	// The GKE cluster name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The GKE cluster network
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Is GKE cluster network policy enabled?
	// +kubebuilder:validation:Optional
	NetworkPolicyEnabled *bool `json:"networkPolicyEnabled,omitempty" tf:"network_policy_enabled,omitempty"`

	// The GKE cluster node pools
	// +kubebuilder:validation:Optional
	NodePools []GkeConfigV2NodePoolsParameters `json:"nodePools,omitempty" tf:"node_pools,omitempty"`

	// The GKE private cluster config
	// +kubebuilder:validation:Optional
	PrivateClusterConfig []PrivateClusterConfigParameters `json:"privateClusterConfig,omitempty" tf:"private_cluster_config,omitempty"`

	// The GKE project id
	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`

	// The GKE cluster region. Required if `zone` is empty
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The GKE cluster subnetwork
	// +kubebuilder:validation:Optional
	Subnetwork *string `json:"subnetwork,omitempty" tf:"subnetwork,omitempty"`

	// The GKE cluster zone. Required if `region` is empty
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type GlobalObservation struct {
	DisableSecurityGroupIngress *bool `json:"disableSecurityGroupIngress,omitempty" tf:"disable_security_group_ingress,omitempty"`

	DisableStrictZoneCheck *bool `json:"disableStrictZoneCheck,omitempty" tf:"disable_strict_zone_check,omitempty"`

	ELBSecurityGroup *string `json:"elbSecurityGroup,omitempty" tf:"elb_security_group,omitempty"`

	KubernetesClusterID *string `json:"kubernetesClusterId,omitempty" tf:"kubernetes_cluster_id,omitempty"`

	KubernetesClusterTag *string `json:"kubernetesClusterTag,omitempty" tf:"kubernetes_cluster_tag,omitempty"`

	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	RouteTableID *string `json:"routeTableId,omitempty" tf:"route_table_id,omitempty"`

	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	VPC *string `json:"vpc,omitempty" tf:"vpc,omitempty"`

	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type GlobalParameters struct {

	// +kubebuilder:validation:Optional
	DisableSecurityGroupIngress *bool `json:"disableSecurityGroupIngress,omitempty" tf:"disable_security_group_ingress,omitempty"`

	// +kubebuilder:validation:Optional
	DisableStrictZoneCheck *bool `json:"disableStrictZoneCheck,omitempty" tf:"disable_strict_zone_check,omitempty"`

	// +kubebuilder:validation:Optional
	ELBSecurityGroup *string `json:"elbSecurityGroup,omitempty" tf:"elb_security_group,omitempty"`

	// +kubebuilder:validation:Optional
	KubernetesClusterID *string `json:"kubernetesClusterId,omitempty" tf:"kubernetes_cluster_id,omitempty"`

	// +kubebuilder:validation:Optional
	KubernetesClusterTag *string `json:"kubernetesClusterTag,omitempty" tf:"kubernetes_cluster_tag,omitempty"`

	// +kubebuilder:validation:Optional
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// +kubebuilder:validation:Optional
	RouteTableID *string `json:"routeTableId,omitempty" tf:"route_table_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	VPC *string `json:"vpc,omitempty" tf:"vpc,omitempty"`

	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type IPAllocationPolicyObservation struct {

	// The GKE cluster ip v4 allocation cidr block
	ClusterIPv4CidrBlock *string `json:"clusterIpv4CidrBlock,omitempty" tf:"cluster_ipv4_cidr_block,omitempty"`

	// The GKE cluster ip v4 allocation secondary range name
	ClusterSecondaryRangeName *string `json:"clusterSecondaryRangeName,omitempty" tf:"cluster_secondary_range_name,omitempty"`

	// Create GKE subnetwork?
	CreateSubnetwork *bool `json:"createSubnetwork,omitempty" tf:"create_subnetwork,omitempty"`

	// The GKE node ip v4 allocation cidr block
	NodeIPv4CidrBlock *string `json:"nodeIpv4CidrBlock,omitempty" tf:"node_ipv4_cidr_block,omitempty"`

	// The GKE services ip v4 allocation cidr block
	ServicesIPv4CidrBlock *string `json:"servicesIpv4CidrBlock,omitempty" tf:"services_ipv4_cidr_block,omitempty"`

	// The GKE services ip v4 allocation secondary range name
	ServicesSecondaryRangeName *string `json:"servicesSecondaryRangeName,omitempty" tf:"services_secondary_range_name,omitempty"`

	// The GKE cluster subnetwork name
	SubnetworkName *string `json:"subnetworkName,omitempty" tf:"subnetwork_name,omitempty"`

	// Use GKE ip aliases?
	UseIPAliases *bool `json:"useIpAliases,omitempty" tf:"use_ip_aliases,omitempty"`
}

type IPAllocationPolicyParameters struct {

	// The GKE cluster ip v4 allocation cidr block
	// +kubebuilder:validation:Optional
	ClusterIPv4CidrBlock *string `json:"clusterIpv4CidrBlock,omitempty" tf:"cluster_ipv4_cidr_block,omitempty"`

	// The GKE cluster ip v4 allocation secondary range name
	// +kubebuilder:validation:Optional
	ClusterSecondaryRangeName *string `json:"clusterSecondaryRangeName,omitempty" tf:"cluster_secondary_range_name,omitempty"`

	// Create GKE subnetwork?
	// +kubebuilder:validation:Optional
	CreateSubnetwork *bool `json:"createSubnetwork,omitempty" tf:"create_subnetwork,omitempty"`

	// The GKE node ip v4 allocation cidr block
	// +kubebuilder:validation:Optional
	NodeIPv4CidrBlock *string `json:"nodeIpv4CidrBlock,omitempty" tf:"node_ipv4_cidr_block,omitempty"`

	// The GKE services ip v4 allocation cidr block
	// +kubebuilder:validation:Optional
	ServicesIPv4CidrBlock *string `json:"servicesIpv4CidrBlock,omitempty" tf:"services_ipv4_cidr_block,omitempty"`

	// The GKE services ip v4 allocation secondary range name
	// +kubebuilder:validation:Optional
	ServicesSecondaryRangeName *string `json:"servicesSecondaryRangeName,omitempty" tf:"services_secondary_range_name,omitempty"`

	// The GKE cluster subnetwork name
	// +kubebuilder:validation:Optional
	SubnetworkName *string `json:"subnetworkName,omitempty" tf:"subnetwork_name,omitempty"`

	// Use GKE ip aliases?
	// +kubebuilder:validation:Optional
	UseIPAliases *bool `json:"useIpAliases,omitempty" tf:"use_ip_aliases,omitempty"`
}

type IngressObservation struct {
	DNSPolicy *string `json:"dnsPolicy,omitempty" tf:"dns_policy,omitempty"`

	DefaultBackend *bool `json:"defaultBackend,omitempty" tf:"default_backend,omitempty"`

	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	HTTPPort *float64 `json:"httpPort,omitempty" tf:"http_port,omitempty"`

	HTTPSPort *float64 `json:"httpsPort,omitempty" tf:"https_port,omitempty"`

	NetworkMode *string `json:"networkMode,omitempty" tf:"network_mode,omitempty"`

	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// Ingress add-on tolerations
	Tolerations []IngressTolerationsObservation `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update daemon set strategy
	UpdateStrategy []IngressUpdateStrategyObservation `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`
}

type IngressParameters struct {

	// +kubebuilder:validation:Optional
	DNSPolicy *string `json:"dnsPolicy,omitempty" tf:"dns_policy,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultBackend *bool `json:"defaultBackend,omitempty" tf:"default_backend,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPPort *float64 `json:"httpPort,omitempty" tf:"http_port,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPSPort *float64 `json:"httpsPort,omitempty" tf:"https_port,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkMode *string `json:"networkMode,omitempty" tf:"network_mode,omitempty"`

	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// Ingress add-on tolerations
	// +kubebuilder:validation:Optional
	Tolerations []IngressTolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update daemon set strategy
	// +kubebuilder:validation:Optional
	UpdateStrategy []IngressUpdateStrategyParameters `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`
}

type IngressTolerationsObservation struct {
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IngressTolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IngressUpdateStrategyObservation struct {

	// Rolling update for update strategy
	RollingUpdate []UpdateStrategyRollingUpdateObservation `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type IngressUpdateStrategyParameters struct {

	// Rolling update for update strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []UpdateStrategyRollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type K3SConfigObservation struct {

	// The K3S upgrade strategy
	UpgradeStrategy []UpgradeStrategyObservation `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// The K3S kubernetes version
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type K3SConfigParameters struct {

	// The K3S upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []UpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// The K3S kubernetes version
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type KubeAPIObservation struct {
	AdmissionConfiguration map[string]*string `json:"admissionConfiguration,omitempty" tf:"admission_configuration,omitempty"`

	AlwaysPullImages *bool `json:"alwaysPullImages,omitempty" tf:"always_pull_images,omitempty"`

	AuditLog []AuditLogObservation `json:"auditLog,omitempty" tf:"audit_log,omitempty"`

	EventRateLimit []EventRateLimitObservation `json:"eventRateLimit,omitempty" tf:"event_rate_limit,omitempty"`

	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	PodSecurityPolicy *bool `json:"podSecurityPolicy,omitempty" tf:"pod_security_policy,omitempty"`

	SecretsEncryptionConfig []SecretsEncryptionConfigObservation `json:"secretsEncryptionConfig,omitempty" tf:"secrets_encryption_config,omitempty"`

	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`

	ServiceNodePortRange *string `json:"serviceNodePortRange,omitempty" tf:"service_node_port_range,omitempty"`
}

type KubeAPIParameters struct {

	// +kubebuilder:validation:Optional
	AdmissionConfiguration map[string]*string `json:"admissionConfiguration,omitempty" tf:"admission_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	AlwaysPullImages *bool `json:"alwaysPullImages,omitempty" tf:"always_pull_images,omitempty"`

	// +kubebuilder:validation:Optional
	AuditLog []AuditLogParameters `json:"auditLog,omitempty" tf:"audit_log,omitempty"`

	// +kubebuilder:validation:Optional
	EventRateLimit []EventRateLimitParameters `json:"eventRateLimit,omitempty" tf:"event_rate_limit,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	PodSecurityPolicy *bool `json:"podSecurityPolicy,omitempty" tf:"pod_security_policy,omitempty"`

	// +kubebuilder:validation:Optional
	SecretsEncryptionConfig []SecretsEncryptionConfigParameters `json:"secretsEncryptionConfig,omitempty" tf:"secrets_encryption_config,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceNodePortRange *string `json:"serviceNodePortRange,omitempty" tf:"service_node_port_range,omitempty"`
}

type KubeControllerObservation struct {
	ClusterCidr *string `json:"clusterCidr,omitempty" tf:"cluster_cidr,omitempty"`

	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`
}

type KubeControllerParameters struct {

	// +kubebuilder:validation:Optional
	ClusterCidr *string `json:"clusterCidr,omitempty" tf:"cluster_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`
}

type KubeletObservation struct {
	ClusterDNSServer *string `json:"clusterDnsServer,omitempty" tf:"cluster_dns_server,omitempty"`

	ClusterDomain *string `json:"clusterDomain,omitempty" tf:"cluster_domain,omitempty"`

	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	FailSwapOn *bool `json:"failSwapOn,omitempty" tf:"fail_swap_on,omitempty"`

	GenerateServingCertificate *bool `json:"generateServingCertificate,omitempty" tf:"generate_serving_certificate,omitempty"`

	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	InfraContainerImage *string `json:"infraContainerImage,omitempty" tf:"infra_container_image,omitempty"`
}

type KubeletParameters struct {

	// +kubebuilder:validation:Optional
	ClusterDNSServer *string `json:"clusterDnsServer,omitempty" tf:"cluster_dns_server,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterDomain *string `json:"clusterDomain,omitempty" tf:"cluster_domain,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	FailSwapOn *bool `json:"failSwapOn,omitempty" tf:"fail_swap_on,omitempty"`

	// +kubebuilder:validation:Optional
	GenerateServingCertificate *bool `json:"generateServingCertificate,omitempty" tf:"generate_serving_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	InfraContainerImage *string `json:"infraContainerImage,omitempty" tf:"infra_container_image,omitempty"`
}

type KubeproxyObservation struct {
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type KubeproxyParameters struct {

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type LaunchTemplateObservation struct {

	// The EKS node group launch template ID
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The EKS node group launch template name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The EKS node group launch template version
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type LaunchTemplateParameters struct {

	// The EKS node group launch template ID
	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`

	// The EKS node group launch template name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The EKS node group launch template version
	// +kubebuilder:validation:Optional
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type LinearAutoscalerParamsObservation struct {
	CoresPerReplica *float64 `json:"coresPerReplica,omitempty" tf:"cores_per_replica,omitempty"`

	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	NodesPerReplica *float64 `json:"nodesPerReplica,omitempty" tf:"nodes_per_replica,omitempty"`

	PreventSinglePointFailure *bool `json:"preventSinglePointFailure,omitempty" tf:"prevent_single_point_failure,omitempty"`
}

type LinearAutoscalerParamsParameters struct {

	// +kubebuilder:validation:Optional
	CoresPerReplica *float64 `json:"coresPerReplica,omitempty" tf:"cores_per_replica,omitempty"`

	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	// +kubebuilder:validation:Optional
	NodesPerReplica *float64 `json:"nodesPerReplica,omitempty" tf:"nodes_per_replica,omitempty"`

	// +kubebuilder:validation:Optional
	PreventSinglePointFailure *bool `json:"preventSinglePointFailure,omitempty" tf:"prevent_single_point_failure,omitempty"`
}

type LoadBalancerObservation struct {
	CreateMonitor *bool `json:"createMonitor,omitempty" tf:"create_monitor,omitempty"`

	FloatingNetworkID *string `json:"floatingNetworkId,omitempty" tf:"floating_network_id,omitempty"`

	LBMethod *string `json:"lbMethod,omitempty" tf:"lb_method,omitempty"`

	LBProvider *string `json:"lbProvider,omitempty" tf:"lb_provider,omitempty"`

	LBVersion *string `json:"lbVersion,omitempty" tf:"lb_version,omitempty"`

	ManageSecurityGroups *bool `json:"manageSecurityGroups,omitempty" tf:"manage_security_groups,omitempty"`

	MonitorDelay *string `json:"monitorDelay,omitempty" tf:"monitor_delay,omitempty"`

	MonitorMaxRetries *float64 `json:"monitorMaxRetries,omitempty" tf:"monitor_max_retries,omitempty"`

	MonitorTimeout *string `json:"monitorTimeout,omitempty" tf:"monitor_timeout,omitempty"`

	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	UseOctavia *bool `json:"useOctavia,omitempty" tf:"use_octavia,omitempty"`
}

type LoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	CreateMonitor *bool `json:"createMonitor,omitempty" tf:"create_monitor,omitempty"`

	// +kubebuilder:validation:Optional
	FloatingNetworkID *string `json:"floatingNetworkId,omitempty" tf:"floating_network_id,omitempty"`

	// +kubebuilder:validation:Optional
	LBMethod *string `json:"lbMethod,omitempty" tf:"lb_method,omitempty"`

	// +kubebuilder:validation:Optional
	LBProvider *string `json:"lbProvider,omitempty" tf:"lb_provider,omitempty"`

	// +kubebuilder:validation:Optional
	LBVersion *string `json:"lbVersion,omitempty" tf:"lb_version,omitempty"`

	// +kubebuilder:validation:Optional
	ManageSecurityGroups *bool `json:"manageSecurityGroups,omitempty" tf:"manage_security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorDelay *string `json:"monitorDelay,omitempty" tf:"monitor_delay,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorMaxRetries *float64 `json:"monitorMaxRetries,omitempty" tf:"monitor_max_retries,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorTimeout *string `json:"monitorTimeout,omitempty" tf:"monitor_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	UseOctavia *bool `json:"useOctavia,omitempty" tf:"use_octavia,omitempty"`
}

type ManagementObservation struct {

	// Enable GKE node pool config management auto repair
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Enable GKE node pool config management auto upgrade
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`
}

type ManagementParameters struct {

	// Enable GKE node pool config management auto repair
	// +kubebuilder:validation:Optional
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Enable GKE node pool config management auto upgrade
	// +kubebuilder:validation:Optional
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`
}

type MasterAuthorizedNetworksConfigObservation struct {

	// The GKE master authorized network config cidr blocks
	CidrBlocks []CidrBlocksObservation `json:"cidrBlocks,omitempty" tf:"cidr_blocks,omitempty"`

	// Enable GKE master authorized network config
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type MasterAuthorizedNetworksConfigParameters struct {

	// The GKE master authorized network config cidr blocks
	// +kubebuilder:validation:Required
	CidrBlocks []CidrBlocksParameters `json:"cidrBlocks" tf:"cidr_blocks,omitempty"`

	// Enable GKE master authorized network config
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type MetadataObservation struct {
	RequestTimeout *float64 `json:"requestTimeout,omitempty" tf:"request_timeout,omitempty"`

	SearchOrder *string `json:"searchOrder,omitempty" tf:"search_order,omitempty"`
}

type MetadataParameters struct {

	// +kubebuilder:validation:Optional
	RequestTimeout *float64 `json:"requestTimeout,omitempty" tf:"request_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SearchOrder *string `json:"searchOrder,omitempty" tf:"search_order,omitempty"`
}

type MonitoringObservation struct {
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	Replicas *float64 `json:"replicas,omitempty" tf:"replicas,omitempty"`

	// Monitoring add-on tolerations
	Tolerations []MonitoringTolerationsObservation `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update deployment strategy
	UpdateStrategy []MonitoringUpdateStrategyObservation `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`
}

type MonitoringParameters struct {

	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	Replicas *float64 `json:"replicas,omitempty" tf:"replicas,omitempty"`

	// Monitoring add-on tolerations
	// +kubebuilder:validation:Optional
	Tolerations []MonitoringTolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update deployment strategy
	// +kubebuilder:validation:Optional
	UpdateStrategy []MonitoringUpdateStrategyParameters `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`
}

type MonitoringTolerationsObservation struct {
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MonitoringTolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MonitoringUpdateStrategyObservation struct {

	// Rolling update for update strategy
	RollingUpdate []MonitoringUpdateStrategyRollingUpdateObservation `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type MonitoringUpdateStrategyParameters struct {

	// Rolling update for update strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []MonitoringUpdateStrategyRollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type MonitoringUpdateStrategyRollingUpdateObservation struct {

	// Rolling update max surge
	MaxSurge *float64 `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// Rolling update max unavailable
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type MonitoringUpdateStrategyRollingUpdateParameters struct {

	// Rolling update max surge
	// +kubebuilder:validation:Optional
	MaxSurge *float64 `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type NetworkObservation struct {
	PublicNetwork *string `json:"publicNetwork,omitempty" tf:"public_network,omitempty"`
}

type NetworkParameters struct {

	// +kubebuilder:validation:Optional
	PublicNetwork *string `json:"publicNetwork,omitempty" tf:"public_network,omitempty"`
}

type NetworkTolerationsObservation struct {
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type NetworkTolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type NodeGroupsObservation struct {

	// The EKS node group desired size
	DesiredSize *float64 `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// The EKS node group disk size
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// The EKS node group ssh key
	EC2SSHKey *string `json:"ec2SshKey,omitempty" tf:"ec2_ssh_key,omitempty"`

	// Is EKS cluster using gpu?
	Gpu *bool `json:"gpu,omitempty" tf:"gpu,omitempty"`

	// The EKS node group image ID
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The EKS node group instance type
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// The EKS node group tags
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The EKS node groups launch template
	LaunchTemplate []LaunchTemplateObservation `json:"launchTemplate,omitempty" tf:"launch_template,omitempty"`

	// The EKS node group maximum size
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The EKS node group minimum size
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// The EKS node group name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The EKS node group node role ARN
	NodeRole *string `json:"nodeRole,omitempty" tf:"node_role,omitempty"`

	// Enable EKS node group request spot instances
	RequestSpotInstances *bool `json:"requestSpotInstances,omitempty" tf:"request_spot_instances,omitempty"`

	// The EKS node group resource tags
	ResourceTags map[string]*string `json:"resourceTags,omitempty" tf:"resource_tags,omitempty"`

	// The EKS node group spot instance types
	SpotInstanceTypes []*string `json:"spotInstanceTypes,omitempty" tf:"spot_instance_types,omitempty"`

	// The EKS node group subnets
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// The EKS node group tags
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The EKS node group user data
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The EKS node group k8s version
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type NodeGroupsParameters struct {

	// The EKS node group desired size
	// +kubebuilder:validation:Optional
	DesiredSize *float64 `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// The EKS node group disk size
	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// The EKS node group ssh key
	// +kubebuilder:validation:Optional
	EC2SSHKey *string `json:"ec2SshKey,omitempty" tf:"ec2_ssh_key,omitempty"`

	// Is EKS cluster using gpu?
	// +kubebuilder:validation:Optional
	Gpu *bool `json:"gpu,omitempty" tf:"gpu,omitempty"`

	// The EKS node group image ID
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The EKS node group instance type
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// The EKS node group tags
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The EKS node groups launch template
	// +kubebuilder:validation:Optional
	LaunchTemplate []LaunchTemplateParameters `json:"launchTemplate,omitempty" tf:"launch_template,omitempty"`

	// The EKS node group maximum size
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The EKS node group minimum size
	// +kubebuilder:validation:Optional
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// The EKS node group name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The EKS node group node role ARN
	// +kubebuilder:validation:Optional
	NodeRole *string `json:"nodeRole,omitempty" tf:"node_role,omitempty"`

	// Enable EKS node group request spot instances
	// +kubebuilder:validation:Optional
	RequestSpotInstances *bool `json:"requestSpotInstances,omitempty" tf:"request_spot_instances,omitempty"`

	// The EKS node group resource tags
	// +kubebuilder:validation:Optional
	ResourceTags map[string]*string `json:"resourceTags,omitempty" tf:"resource_tags,omitempty"`

	// The EKS node group spot instance types
	// +kubebuilder:validation:Optional
	SpotInstanceTypes []*string `json:"spotInstanceTypes,omitempty" tf:"spot_instance_types,omitempty"`

	// The EKS node group subnets
	// +kubebuilder:validation:Optional
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// The EKS node group tags
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The EKS node group user data
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

type NodePoolsObservation struct {

	// The AKS node pool availability zones
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// The AKS node pool count
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`

	// Is AKS node pool auto scaling enabled?
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty" tf:"enable_auto_scaling,omitempty"`

	// The AKS node pool max count
	MaxCount *float64 `json:"maxCount,omitempty" tf:"max_count,omitempty"`

	// The AKS node pool max pods
	MaxPods *float64 `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// The AKS node pool min count
	MinCount *float64 `json:"minCount,omitempty" tf:"min_count,omitempty"`

	// The AKS node pool mode
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// The AKS node group name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The AKS node pool orchestrator version
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty" tf:"orchestrator_version,omitempty"`

	// The AKS node pool os disk size gb
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// The AKS node pool os disk type
	OsDiskType *string `json:"osDiskType,omitempty" tf:"os_disk_type,omitempty"`

	// Enable AKS node pool os type
	OsType *string `json:"osType,omitempty" tf:"os_type,omitempty"`

	// The AKS node pool vm size
	VMSize *string `json:"vmSize,omitempty" tf:"vm_size,omitempty"`
}

type NodePoolsParameters struct {

	// The AKS node pool availability zones
	// +kubebuilder:validation:Optional
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// The AKS node pool count
	// +kubebuilder:validation:Optional
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`

	// Is AKS node pool auto scaling enabled?
	// +kubebuilder:validation:Optional
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty" tf:"enable_auto_scaling,omitempty"`

	// The AKS node pool max count
	// +kubebuilder:validation:Optional
	MaxCount *float64 `json:"maxCount,omitempty" tf:"max_count,omitempty"`

	// The AKS node pool max pods
	// +kubebuilder:validation:Optional
	MaxPods *float64 `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// The AKS node pool min count
	// +kubebuilder:validation:Optional
	MinCount *float64 `json:"minCount,omitempty" tf:"min_count,omitempty"`

	// The AKS node pool mode
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// The AKS node group name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The AKS node pool orchestrator version
	// +kubebuilder:validation:Optional
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty" tf:"orchestrator_version,omitempty"`

	// The AKS node pool os disk size gb
	// +kubebuilder:validation:Optional
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// The AKS node pool os disk type
	// +kubebuilder:validation:Optional
	OsDiskType *string `json:"osDiskType,omitempty" tf:"os_disk_type,omitempty"`

	// Enable AKS node pool os type
	// +kubebuilder:validation:Optional
	OsType *string `json:"osType,omitempty" tf:"os_type,omitempty"`

	// The AKS node pool vm size
	// +kubebuilder:validation:Optional
	VMSize *string `json:"vmSize,omitempty" tf:"vm_size,omitempty"`
}

type NodelocalObservation struct {
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// Node selector key pair
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`
}

type NodelocalParameters struct {

	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// Node selector key pair
	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`
}

type NodesObservation struct {
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	DockerSocket *string `json:"dockerSocket,omitempty" tf:"docker_socket,omitempty"`

	HostnameOverride *string `json:"hostnameOverride,omitempty" tf:"hostname_override,omitempty"`

	InternalAddress *string `json:"internalAddress,omitempty" tf:"internal_address,omitempty"`

	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	NodeID *string `json:"nodeId,omitempty" tf:"node_id,omitempty"`

	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	Role []*string `json:"role,omitempty" tf:"role,omitempty"`

	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`
}

type NodesParameters struct {

	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	DockerSocket *string `json:"dockerSocket,omitempty" tf:"docker_socket,omitempty"`

	// +kubebuilder:validation:Optional
	HostnameOverride *string `json:"hostnameOverride,omitempty" tf:"hostname_override,omitempty"`

	// +kubebuilder:validation:Optional
	InternalAddress *string `json:"internalAddress,omitempty" tf:"internal_address,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	NodeID *string `json:"nodeId,omitempty" tf:"node_id,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Role []*string `json:"role" tf:"role,omitempty"`

	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeySecretRef *v1.SecretKeySelector `json:"sshKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	UserSecretRef v1.SecretKeySelector `json:"userSecretRef" tf:"-"`
}

type OkeConfigObservation struct {

	// The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// An optional custom boot volume size (in GB) for the nodes
	CustomBootVolumeSize *float64 `json:"customBootVolumeSize,omitempty" tf:"custom_boot_volume_size,omitempty"`

	// An optional description of this cluster
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Enable the kubernetes dashboard
	EnableKubernetesDashboard *bool `json:"enableKubernetesDashboard,omitempty" tf:"enable_kubernetes_dashboard,omitempty"`

	// Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
	EnablePrivateControlPlane *bool `json:"enablePrivateControlPlane,omitempty" tf:"enable_private_control_plane,omitempty"`

	// Whether worker nodes are deployed into a new private subnet
	EnablePrivateNodes *bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`

	// The fingerprint corresponding to the specified user's private API Key
	Fingerprint *string `json:"fingerprint,omitempty" tf:"fingerprint,omitempty"`

	// Optional number of OCPUs for nodes (requires flexible node_shape)
	FlexOcpus *float64 `json:"flexOcpus,omitempty" tf:"flex_ocpus,omitempty"`

	// The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.19.7
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Optional limit on the total number of nodes in the pool
	LimitNodeCount *float64 `json:"limitNodeCount,omitempty" tf:"limit_node_count,omitempty"`

	// The name of the first existing subnet to use for Kubernetes services / LB
	LoadBalancerSubnetName1 *string `json:"loadBalancerSubnetName1,omitempty" tf:"load_balancer_subnet_name_1,omitempty"`

	// The (optional) name of a second existing subnet to use for Kubernetes services / LB
	LoadBalancerSubnetName2 *string `json:"loadBalancerSubnetName2,omitempty" tf:"load_balancer_subnet_name_2,omitempty"`

	// The OS for the node image
	NodeImage *string `json:"nodeImage,omitempty" tf:"node_image,omitempty"`

	// Optional name for DNS domain of node pool subnet
	NodePoolDNSDomainName *string `json:"nodePoolDnsDomainName,omitempty" tf:"node_pool_dns_domain_name,omitempty"`

	// Optional name for node pool subnet
	NodePoolSubnetName *string `json:"nodePoolSubnetName,omitempty" tf:"node_pool_subnet_name,omitempty"`

	// The contents of the SSH public key file to use for the nodes
	NodePublicKeyContents *string `json:"nodePublicKeyContents,omitempty" tf:"node_public_key_contents,omitempty"`

	// The shape of the node (determines number of CPUs and  amount of memory on each node)
	NodeShape *string `json:"nodeShape,omitempty" tf:"node_shape,omitempty"`

	// Optional specify the pod CIDR, defaults to 10.244.0.0/16
	PodCidr *string `json:"podCidr,omitempty" tf:"pod_cidr,omitempty"`

	// Number of node subnets (defaults to creating 1 regional subnet)
	QuantityOfNodeSubnets *float64 `json:"quantityOfNodeSubnets,omitempty" tf:"quantity_of_node_subnets,omitempty"`

	// Number of worker nodes in each subnet / availability domain
	QuantityPerSubnet *float64 `json:"quantityPerSubnet,omitempty" tf:"quantity_per_subnet,omitempty"`

	// The availability domain within the region to host the OKE cluster
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Optional specify the service CIDR, defaults to 10.96.0.0/16
	ServiceCidr *string `json:"serviceCidr,omitempty" tf:"service_cidr,omitempty"`

	// Optional name for DNS domain of service subnet
	ServiceDNSDomainName *string `json:"serviceDnsDomainName,omitempty" tf:"service_dns_domain_name,omitempty"`

	// Whether to skip deleting VCN
	SkipVcnDelete *bool `json:"skipVcnDelete,omitempty" tf:"skip_vcn_delete,omitempty"`

	// The OCID of the tenancy in which to create resources
	TenancyID *string `json:"tenancyId,omitempty" tf:"tenancy_id,omitempty"`

	// The OCID of a user who has access to the tenancy/compartment
	UserOcid *string `json:"userOcid,omitempty" tf:"user_ocid,omitempty"`

	// The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
	VcnCompartmentID *string `json:"vcnCompartmentId,omitempty" tf:"vcn_compartment_id,omitempty"`

	// The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
	VcnName *string `json:"vcnName,omitempty" tf:"vcn_name,omitempty"`

	// Additional CIDR from which to allow ingress to worker nodes
	WorkerNodeIngressCidr *string `json:"workerNodeIngressCidr,omitempty" tf:"worker_node_ingress_cidr,omitempty"`
}

type OkeConfigParameters struct {

	// The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
	// +kubebuilder:validation:Required
	CompartmentID *string `json:"compartmentId" tf:"compartment_id,omitempty"`

	// An optional custom boot volume size (in GB) for the nodes
	// +kubebuilder:validation:Optional
	CustomBootVolumeSize *float64 `json:"customBootVolumeSize,omitempty" tf:"custom_boot_volume_size,omitempty"`

	// An optional description of this cluster
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Enable the kubernetes dashboard
	// +kubebuilder:validation:Optional
	EnableKubernetesDashboard *bool `json:"enableKubernetesDashboard,omitempty" tf:"enable_kubernetes_dashboard,omitempty"`

	// Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
	// +kubebuilder:validation:Optional
	EnablePrivateControlPlane *bool `json:"enablePrivateControlPlane,omitempty" tf:"enable_private_control_plane,omitempty"`

	// Whether worker nodes are deployed into a new private subnet
	// +kubebuilder:validation:Optional
	EnablePrivateNodes *bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`

	// The fingerprint corresponding to the specified user's private API Key
	// +kubebuilder:validation:Required
	Fingerprint *string `json:"fingerprint" tf:"fingerprint,omitempty"`

	// Optional number of OCPUs for nodes (requires flexible node_shape)
	// +kubebuilder:validation:Optional
	FlexOcpus *float64 `json:"flexOcpus,omitempty" tf:"flex_ocpus,omitempty"`

	// Optional specify the OCID of the KMS Vault master key
	// +kubebuilder:validation:Optional
	KMSKeyIDSecretRef *v1.SecretKeySelector `json:"kmsKeyIdSecretRef,omitempty" tf:"-"`

	// The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.19.7
	// +kubebuilder:validation:Required
	KubernetesVersion *string `json:"kubernetesVersion" tf:"kubernetes_version,omitempty"`

	// Optional limit on the total number of nodes in the pool
	// +kubebuilder:validation:Optional
	LimitNodeCount *float64 `json:"limitNodeCount,omitempty" tf:"limit_node_count,omitempty"`

	// The name of the first existing subnet to use for Kubernetes services / LB
	// +kubebuilder:validation:Optional
	LoadBalancerSubnetName1 *string `json:"loadBalancerSubnetName1,omitempty" tf:"load_balancer_subnet_name_1,omitempty"`

	// The (optional) name of a second existing subnet to use for Kubernetes services / LB
	// +kubebuilder:validation:Optional
	LoadBalancerSubnetName2 *string `json:"loadBalancerSubnetName2,omitempty" tf:"load_balancer_subnet_name_2,omitempty"`

	// The OS for the node image
	// +kubebuilder:validation:Required
	NodeImage *string `json:"nodeImage" tf:"node_image,omitempty"`

	// Optional name for DNS domain of node pool subnet
	// +kubebuilder:validation:Optional
	NodePoolDNSDomainName *string `json:"nodePoolDnsDomainName,omitempty" tf:"node_pool_dns_domain_name,omitempty"`

	// Optional name for node pool subnet
	// +kubebuilder:validation:Optional
	NodePoolSubnetName *string `json:"nodePoolSubnetName,omitempty" tf:"node_pool_subnet_name,omitempty"`

	// The contents of the SSH public key file to use for the nodes
	// +kubebuilder:validation:Optional
	NodePublicKeyContents *string `json:"nodePublicKeyContents,omitempty" tf:"node_public_key_contents,omitempty"`

	// The shape of the node (determines number of CPUs and  amount of memory on each node)
	// +kubebuilder:validation:Required
	NodeShape *string `json:"nodeShape" tf:"node_shape,omitempty"`

	// Optional specify the pod CIDR, defaults to 10.244.0.0/16
	// +kubebuilder:validation:Optional
	PodCidr *string `json:"podCidr,omitempty" tf:"pod_cidr,omitempty"`

	// The private API key file contents for the specified user, in PEM format
	// +kubebuilder:validation:Required
	PrivateKeyContentsSecretRef v1.SecretKeySelector `json:"privateKeyContentsSecretRef" tf:"-"`

	// The passphrase of the private key for the OKE cluster
	// +kubebuilder:validation:Optional
	PrivateKeyPassphraseSecretRef *v1.SecretKeySelector `json:"privateKeyPassphraseSecretRef,omitempty" tf:"-"`

	// Number of node subnets (defaults to creating 1 regional subnet)
	// +kubebuilder:validation:Optional
	QuantityOfNodeSubnets *float64 `json:"quantityOfNodeSubnets,omitempty" tf:"quantity_of_node_subnets,omitempty"`

	// Number of worker nodes in each subnet / availability domain
	// +kubebuilder:validation:Optional
	QuantityPerSubnet *float64 `json:"quantityPerSubnet,omitempty" tf:"quantity_per_subnet,omitempty"`

	// The availability domain within the region to host the OKE cluster
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// Optional specify the service CIDR, defaults to 10.96.0.0/16
	// +kubebuilder:validation:Optional
	ServiceCidr *string `json:"serviceCidr,omitempty" tf:"service_cidr,omitempty"`

	// Optional name for DNS domain of service subnet
	// +kubebuilder:validation:Optional
	ServiceDNSDomainName *string `json:"serviceDnsDomainName,omitempty" tf:"service_dns_domain_name,omitempty"`

	// Whether to skip deleting VCN
	// +kubebuilder:validation:Optional
	SkipVcnDelete *bool `json:"skipVcnDelete,omitempty" tf:"skip_vcn_delete,omitempty"`

	// The OCID of the tenancy in which to create resources
	// +kubebuilder:validation:Required
	TenancyID *string `json:"tenancyId" tf:"tenancy_id,omitempty"`

	// The OCID of a user who has access to the tenancy/compartment
	// +kubebuilder:validation:Required
	UserOcid *string `json:"userOcid" tf:"user_ocid,omitempty"`

	// The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
	// +kubebuilder:validation:Optional
	VcnCompartmentID *string `json:"vcnCompartmentId,omitempty" tf:"vcn_compartment_id,omitempty"`

	// The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
	// +kubebuilder:validation:Optional
	VcnName *string `json:"vcnName,omitempty" tf:"vcn_name,omitempty"`

	// Additional CIDR from which to allow ingress to worker nodes
	// +kubebuilder:validation:Optional
	WorkerNodeIngressCidr *string `json:"workerNodeIngressCidr,omitempty" tf:"worker_node_ingress_cidr,omitempty"`
}

type OpenstackCloudProviderGlobalObservation struct {
	AuthURL *string `json:"authUrl,omitempty" tf:"auth_url,omitempty"`

	CAFile *string `json:"caFile,omitempty" tf:"ca_file,omitempty"`

	DomainName *string `json:"domainName,omitempty" tf:"domain_name,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	TenantName *string `json:"tenantName,omitempty" tf:"tenant_name,omitempty"`
}

type OpenstackCloudProviderGlobalParameters struct {

	// +kubebuilder:validation:Required
	AuthURL *string `json:"authUrl" tf:"auth_url,omitempty"`

	// +kubebuilder:validation:Optional
	CAFile *string `json:"caFile,omitempty" tf:"ca_file,omitempty"`

	// +kubebuilder:validation:Optional
	DomainIDSecretRef *v1.SecretKeySelector `json:"domainIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DomainName *string `json:"domainName,omitempty" tf:"domain_name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	TenantIDSecretRef *v1.SecretKeySelector `json:"tenantIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TenantName *string `json:"tenantName,omitempty" tf:"tenant_name,omitempty"`

	// +kubebuilder:validation:Optional
	TrustIDSecretRef *v1.SecretKeySelector `json:"trustIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	UsernameSecretRef v1.SecretKeySelector `json:"usernameSecretRef" tf:"-"`
}

type OpenstackCloudProviderObservation struct {
	BlockStorage []BlockStorageObservation `json:"blockStorage,omitempty" tf:"block_storage,omitempty"`

	Global []OpenstackCloudProviderGlobalObservation `json:"global,omitempty" tf:"global,omitempty"`

	LoadBalancer []LoadBalancerObservation `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	Metadata []MetadataObservation `json:"metadata,omitempty" tf:"metadata,omitempty"`

	Route []RouteObservation `json:"route,omitempty" tf:"route,omitempty"`
}

type OpenstackCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	BlockStorage []BlockStorageParameters `json:"blockStorage,omitempty" tf:"block_storage,omitempty"`

	// +kubebuilder:validation:Required
	Global []OpenstackCloudProviderGlobalParameters `json:"global" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	Route []RouteParameters `json:"route,omitempty" tf:"route,omitempty"`
}

type PrivateClusterConfigObservation struct {

	// Enable GKE cluster private endpoint
	EnablePrivateEndpoint *bool `json:"enablePrivateEndpoint,omitempty" tf:"enable_private_endpoint,omitempty"`

	// Enable GKE cluster private nodes
	EnablePrivateNodes *bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`

	// The GKE cluster private master ip v4 cidr block
	MasterIPv4CidrBlock *string `json:"masterIpv4CidrBlock,omitempty" tf:"master_ipv4_cidr_block,omitempty"`
}

type PrivateClusterConfigParameters struct {

	// Enable GKE cluster private endpoint
	// +kubebuilder:validation:Optional
	EnablePrivateEndpoint *bool `json:"enablePrivateEndpoint,omitempty" tf:"enable_private_endpoint,omitempty"`

	// Enable GKE cluster private nodes
	// +kubebuilder:validation:Optional
	EnablePrivateNodes *bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`

	// The GKE cluster private master ip v4 cidr block
	// +kubebuilder:validation:Required
	MasterIPv4CidrBlock *string `json:"masterIpv4CidrBlock" tf:"master_ipv4_cidr_block,omitempty"`
}

type PrivateRegistriesObservation struct {

	// ECR credential plugin config
	EcrCredentialPlugin []EcrCredentialPluginObservation `json:"ecrCredentialPlugin,omitempty" tf:"ecr_credential_plugin,omitempty"`

	IsDefault *bool `json:"isDefault,omitempty" tf:"is_default,omitempty"`

	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PrivateRegistriesParameters struct {

	// ECR credential plugin config
	// +kubebuilder:validation:Optional
	EcrCredentialPlugin []EcrCredentialPluginParameters `json:"ecrCredentialPlugin,omitempty" tf:"ecr_credential_plugin,omitempty"`

	// +kubebuilder:validation:Optional
	IsDefault *bool `json:"isDefault,omitempty" tf:"is_default,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`

	// +kubebuilder:validation:Optional
	UserSecretRef *v1.SecretKeySelector `json:"userSecretRef,omitempty" tf:"-"`
}

type Rke2ConfigObservation struct {

	// The RKE2 upgrade strategy
	UpgradeStrategy []Rke2ConfigUpgradeStrategyObservation `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// The RKE2 kubernetes version
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type Rke2ConfigParameters struct {

	// The RKE2 upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []Rke2ConfigUpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// The RKE2 kubernetes version
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type Rke2ConfigUpgradeStrategyObservation struct {

	// Drain server nodes
	DrainServerNodes *bool `json:"drainServerNodes,omitempty" tf:"drain_server_nodes,omitempty"`

	// Drain worker nodes
	DrainWorkerNodes *bool `json:"drainWorkerNodes,omitempty" tf:"drain_worker_nodes,omitempty"`

	// Server concurrency
	ServerConcurrency *float64 `json:"serverConcurrency,omitempty" tf:"server_concurrency,omitempty"`

	// Worker concurrency
	WorkerConcurrency *float64 `json:"workerConcurrency,omitempty" tf:"worker_concurrency,omitempty"`
}

type Rke2ConfigUpgradeStrategyParameters struct {

	// Drain server nodes
	// +kubebuilder:validation:Optional
	DrainServerNodes *bool `json:"drainServerNodes,omitempty" tf:"drain_server_nodes,omitempty"`

	// Drain worker nodes
	// +kubebuilder:validation:Optional
	DrainWorkerNodes *bool `json:"drainWorkerNodes,omitempty" tf:"drain_worker_nodes,omitempty"`

	// Server concurrency
	// +kubebuilder:validation:Optional
	ServerConcurrency *float64 `json:"serverConcurrency,omitempty" tf:"server_concurrency,omitempty"`

	// Worker concurrency
	// +kubebuilder:validation:Optional
	WorkerConcurrency *float64 `json:"workerConcurrency,omitempty" tf:"worker_concurrency,omitempty"`
}

type RkeConfigNetworkObservation struct {
	AciNetworkProvider []AciNetworkProviderObservation `json:"aciNetworkProvider,omitempty" tf:"aci_network_provider,omitempty"`

	CalicoNetworkProvider []CalicoNetworkProviderObservation `json:"calicoNetworkProvider,omitempty" tf:"calico_network_provider,omitempty"`

	CanalNetworkProvider []CanalNetworkProviderObservation `json:"canalNetworkProvider,omitempty" tf:"canal_network_provider,omitempty"`

	FlannelNetworkProvider []FlannelNetworkProviderObservation `json:"flannelNetworkProvider,omitempty" tf:"flannel_network_provider,omitempty"`

	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	Plugin *string `json:"plugin,omitempty" tf:"plugin,omitempty"`

	// Network add-on tolerations
	Tolerations []NetworkTolerationsObservation `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	WeaveNetworkProvider []WeaveNetworkProviderObservation `json:"weaveNetworkProvider,omitempty" tf:"weave_network_provider,omitempty"`
}

type RkeConfigNetworkParameters struct {

	// +kubebuilder:validation:Optional
	AciNetworkProvider []AciNetworkProviderParameters `json:"aciNetworkProvider,omitempty" tf:"aci_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	CalicoNetworkProvider []CalicoNetworkProviderParameters `json:"calicoNetworkProvider,omitempty" tf:"calico_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	CanalNetworkProvider []CanalNetworkProviderParameters `json:"canalNetworkProvider,omitempty" tf:"canal_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	FlannelNetworkProvider []FlannelNetworkProviderParameters `json:"flannelNetworkProvider,omitempty" tf:"flannel_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Plugin *string `json:"plugin,omitempty" tf:"plugin,omitempty"`

	// Network add-on tolerations
	// +kubebuilder:validation:Optional
	Tolerations []NetworkTolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// +kubebuilder:validation:Optional
	WeaveNetworkProvider []WeaveNetworkProviderParameters `json:"weaveNetworkProvider,omitempty" tf:"weave_network_provider,omitempty"`
}

type RkeConfigObservation struct {

	// Optional duration in seconds of addon job.
	AddonJobTimeout *float64 `json:"addonJobTimeout,omitempty" tf:"addon_job_timeout,omitempty"`

	// Optional addons descripton to deploy on rke cluster.
	Addons *string `json:"addons,omitempty" tf:"addons,omitempty"`

	// Optional addons yaml manisfest to deploy on rke cluster.
	AddonsInclude []*string `json:"addonsInclude,omitempty" tf:"addons_include,omitempty"`

	// Kubernetes cluster authentication
	Authentication []AuthenticationObservation `json:"authentication,omitempty" tf:"authentication,omitempty"`

	// Kubernetes cluster authorization
	Authorization []AuthorizationObservation `json:"authorization,omitempty" tf:"authorization,omitempty"`

	// RKE bastion host
	BastionHost []BastionHostObservation `json:"bastionHost,omitempty" tf:"bastion_host,omitempty"`

	CloudProvider []CloudProviderObservation `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`

	DNS []DNSObservation `json:"dns,omitempty" tf:"dns,omitempty"`

	// Enable/disable using cri-dockerd
	EnableCriDockerd *bool `json:"enableCriDockerd,omitempty" tf:"enable_cri_dockerd,omitempty"`

	// Optional ignore docker version on nodes
	IgnoreDockerVersion *bool `json:"ignoreDockerVersion,omitempty" tf:"ignore_docker_version,omitempty"`

	// Kubernetes ingress configuration
	Ingress []IngressObservation `json:"ingress,omitempty" tf:"ingress,omitempty"`

	// Optional kubernetes version to deploy
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Kubernetes cluster monitoring
	Monitoring []MonitoringObservation `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// Kubernetes cluster networking
	Network []RkeConfigNetworkObservation `json:"network,omitempty" tf:"network,omitempty"`

	// Optional RKE cluster nodes
	Nodes []NodesObservation `json:"nodes,omitempty" tf:"nodes,omitempty"`

	// Optional prefix to customize kubernetes path
	PrefixPath *string `json:"prefixPath,omitempty" tf:"prefix_path,omitempty"`

	// Optional private registries for docker images
	PrivateRegistries []PrivateRegistriesObservation `json:"privateRegistries,omitempty" tf:"private_registries,omitempty"`

	// Optional use ssh agent auth
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// Optional cluster level SSH certificate path
	SSHCertPath *string `json:"sshCertPath,omitempty" tf:"ssh_cert_path,omitempty"`

	// Optional cluster level SSH private key path
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// Kubernetes cluster services
	Services []ServicesObservation `json:"services,omitempty" tf:"services,omitempty"`

	// RKE upgrade strategy
	UpgradeStrategy []RkeConfigUpgradeStrategyObservation `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// Optional prefix to customize kubernetes path for windows
	WinPrefixPath *string `json:"winPrefixPath,omitempty" tf:"win_prefix_path,omitempty"`
}

type RkeConfigParameters struct {

	// Optional duration in seconds of addon job.
	// +kubebuilder:validation:Optional
	AddonJobTimeout *float64 `json:"addonJobTimeout,omitempty" tf:"addon_job_timeout,omitempty"`

	// Optional addons descripton to deploy on rke cluster.
	// +kubebuilder:validation:Optional
	Addons *string `json:"addons,omitempty" tf:"addons,omitempty"`

	// Optional addons yaml manisfest to deploy on rke cluster.
	// +kubebuilder:validation:Optional
	AddonsInclude []*string `json:"addonsInclude,omitempty" tf:"addons_include,omitempty"`

	// Kubernetes cluster authentication
	// +kubebuilder:validation:Optional
	Authentication []AuthenticationParameters `json:"authentication,omitempty" tf:"authentication,omitempty"`

	// Kubernetes cluster authorization
	// +kubebuilder:validation:Optional
	Authorization []AuthorizationParameters `json:"authorization,omitempty" tf:"authorization,omitempty"`

	// RKE bastion host
	// +kubebuilder:validation:Optional
	BastionHost []BastionHostParameters `json:"bastionHost,omitempty" tf:"bastion_host,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProvider []CloudProviderParameters `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	DNS []DNSParameters `json:"dns,omitempty" tf:"dns,omitempty"`

	// Enable/disable using cri-dockerd
	// +kubebuilder:validation:Optional
	EnableCriDockerd *bool `json:"enableCriDockerd,omitempty" tf:"enable_cri_dockerd,omitempty"`

	// Optional ignore docker version on nodes
	// +kubebuilder:validation:Optional
	IgnoreDockerVersion *bool `json:"ignoreDockerVersion,omitempty" tf:"ignore_docker_version,omitempty"`

	// Kubernetes ingress configuration
	// +kubebuilder:validation:Optional
	Ingress []IngressParameters `json:"ingress,omitempty" tf:"ingress,omitempty"`

	// Optional kubernetes version to deploy
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Kubernetes cluster monitoring
	// +kubebuilder:validation:Optional
	Monitoring []MonitoringParameters `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// Kubernetes cluster networking
	// +kubebuilder:validation:Optional
	Network []RkeConfigNetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// Optional RKE cluster nodes
	// +kubebuilder:validation:Optional
	Nodes []NodesParameters `json:"nodes,omitempty" tf:"nodes,omitempty"`

	// Optional prefix to customize kubernetes path
	// +kubebuilder:validation:Optional
	PrefixPath *string `json:"prefixPath,omitempty" tf:"prefix_path,omitempty"`

	// Optional private registries for docker images
	// +kubebuilder:validation:Optional
	PrivateRegistries []PrivateRegistriesParameters `json:"privateRegistries,omitempty" tf:"private_registries,omitempty"`

	// Optional use ssh agent auth
	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// Optional cluster level SSH certificate path
	// +kubebuilder:validation:Optional
	SSHCertPath *string `json:"sshCertPath,omitempty" tf:"ssh_cert_path,omitempty"`

	// Optional cluster level SSH private key path
	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// Kubernetes cluster services
	// +kubebuilder:validation:Optional
	Services []ServicesParameters `json:"services,omitempty" tf:"services,omitempty"`

	// RKE upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []RkeConfigUpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// Optional prefix to customize kubernetes path for windows
	// +kubebuilder:validation:Optional
	WinPrefixPath *string `json:"winPrefixPath,omitempty" tf:"win_prefix_path,omitempty"`
}

type RkeConfigUpgradeStrategyObservation struct {
	Drain *bool `json:"drain,omitempty" tf:"drain,omitempty"`

	DrainInput []DrainInputObservation `json:"drainInput,omitempty" tf:"drain_input,omitempty"`

	MaxUnavailableControlplane *string `json:"maxUnavailableControlplane,omitempty" tf:"max_unavailable_controlplane,omitempty"`

	MaxUnavailableWorker *string `json:"maxUnavailableWorker,omitempty" tf:"max_unavailable_worker,omitempty"`
}

type RkeConfigUpgradeStrategyParameters struct {

	// +kubebuilder:validation:Optional
	Drain *bool `json:"drain,omitempty" tf:"drain,omitempty"`

	// +kubebuilder:validation:Optional
	DrainInput []DrainInputParameters `json:"drainInput,omitempty" tf:"drain_input,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnavailableControlplane *string `json:"maxUnavailableControlplane,omitempty" tf:"max_unavailable_controlplane,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnavailableWorker *string `json:"maxUnavailableWorker,omitempty" tf:"max_unavailable_worker,omitempty"`
}

type RollingUpdateObservation struct {

	// Rolling update max surge
	MaxSurge *float64 `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// Rolling update max unavailable
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type RollingUpdateParameters struct {

	// Rolling update max surge
	// +kubebuilder:validation:Optional
	MaxSurge *float64 `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type RouteObservation struct {
	RouterID *string `json:"routerId,omitempty" tf:"router_id,omitempty"`
}

type RouteParameters struct {

	// +kubebuilder:validation:Optional
	RouterID *string `json:"routerId,omitempty" tf:"router_id,omitempty"`
}

type S3BackupConfigObservation struct {
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	CustomCA *string `json:"customCa,omitempty" tf:"custom_ca,omitempty"`

	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type S3BackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	AccessKeySecretRef *v1.SecretKeySelector `json:"accessKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	BucketName *string `json:"bucketName" tf:"bucket_name,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCA *string `json:"customCa,omitempty" tf:"custom_ca,omitempty"`

	// +kubebuilder:validation:Required
	Endpoint *string `json:"endpoint" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	SecretKeySecretRef *v1.SecretKeySelector `json:"secretKeySecretRef,omitempty" tf:"-"`
}

type SchedulerObservation struct {
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type SchedulerParameters struct {

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type SecretsEncryptionConfigObservation struct {
	CustomConfig *string `json:"customConfig,omitempty" tf:"custom_config,omitempty"`

	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type SecretsEncryptionConfigParameters struct {

	// +kubebuilder:validation:Optional
	CustomConfig *string `json:"customConfig,omitempty" tf:"custom_config,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ServiceOverrideObservation struct {
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	Service *string `json:"service,omitempty" tf:"service,omitempty"`

	SigningMethod *string `json:"signingMethod,omitempty" tf:"signing_method,omitempty"`

	SigningName *string `json:"signingName,omitempty" tf:"signing_name,omitempty"`

	SigningRegion *string `json:"signingRegion,omitempty" tf:"signing_region,omitempty"`

	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type ServiceOverrideParameters struct {

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Required
	Service *string `json:"service" tf:"service,omitempty"`

	// +kubebuilder:validation:Optional
	SigningMethod *string `json:"signingMethod,omitempty" tf:"signing_method,omitempty"`

	// +kubebuilder:validation:Optional
	SigningName *string `json:"signingName,omitempty" tf:"signing_name,omitempty"`

	// +kubebuilder:validation:Optional
	SigningRegion *string `json:"signingRegion,omitempty" tf:"signing_region,omitempty"`

	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type ServicesObservation struct {
	Etcd []EtcdObservation `json:"etcd,omitempty" tf:"etcd,omitempty"`

	KubeAPI []KubeAPIObservation `json:"kubeApi,omitempty" tf:"kube_api,omitempty"`

	KubeController []KubeControllerObservation `json:"kubeController,omitempty" tf:"kube_controller,omitempty"`

	Kubelet []KubeletObservation `json:"kubelet,omitempty" tf:"kubelet,omitempty"`

	Kubeproxy []KubeproxyObservation `json:"kubeproxy,omitempty" tf:"kubeproxy,omitempty"`

	Scheduler []SchedulerObservation `json:"scheduler,omitempty" tf:"scheduler,omitempty"`
}

type ServicesParameters struct {

	// +kubebuilder:validation:Optional
	Etcd []EtcdParameters `json:"etcd,omitempty" tf:"etcd,omitempty"`

	// +kubebuilder:validation:Optional
	KubeAPI []KubeAPIParameters `json:"kubeApi,omitempty" tf:"kube_api,omitempty"`

	// +kubebuilder:validation:Optional
	KubeController []KubeControllerParameters `json:"kubeController,omitempty" tf:"kube_controller,omitempty"`

	// +kubebuilder:validation:Optional
	Kubelet []KubeletParameters `json:"kubelet,omitempty" tf:"kubelet,omitempty"`

	// +kubebuilder:validation:Optional
	Kubeproxy []KubeproxyParameters `json:"kubeproxy,omitempty" tf:"kubeproxy,omitempty"`

	// +kubebuilder:validation:Optional
	Scheduler []SchedulerParameters `json:"scheduler,omitempty" tf:"scheduler,omitempty"`
}

type TaintsObservation struct {
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsParameters struct {

	// +kubebuilder:validation:Required
	Effect *string `json:"effect" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type TolerationsObservation struct {
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type UpdateStrategyObservation struct {

	// Rolling update for update strategy
	RollingUpdate []RollingUpdateObservation `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type UpdateStrategyParameters struct {

	// Rolling update for update strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []RollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type UpdateStrategyRollingUpdateObservation struct {

	// Rolling update max unavailable
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type UpdateStrategyRollingUpdateParameters struct {

	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type UpgradeStrategyObservation struct {

	// Drain server nodes
	DrainServerNodes *bool `json:"drainServerNodes,omitempty" tf:"drain_server_nodes,omitempty"`

	// Drain worker nodes
	DrainWorkerNodes *bool `json:"drainWorkerNodes,omitempty" tf:"drain_worker_nodes,omitempty"`

	// Server concurrency
	ServerConcurrency *float64 `json:"serverConcurrency,omitempty" tf:"server_concurrency,omitempty"`

	// Worker concurrency
	WorkerConcurrency *float64 `json:"workerConcurrency,omitempty" tf:"worker_concurrency,omitempty"`
}

type UpgradeStrategyParameters struct {

	// Drain server nodes
	// +kubebuilder:validation:Optional
	DrainServerNodes *bool `json:"drainServerNodes,omitempty" tf:"drain_server_nodes,omitempty"`

	// Drain worker nodes
	// +kubebuilder:validation:Optional
	DrainWorkerNodes *bool `json:"drainWorkerNodes,omitempty" tf:"drain_worker_nodes,omitempty"`

	// Server concurrency
	// +kubebuilder:validation:Optional
	ServerConcurrency *float64 `json:"serverConcurrency,omitempty" tf:"server_concurrency,omitempty"`

	// Worker concurrency
	// +kubebuilder:validation:Optional
	WorkerConcurrency *float64 `json:"workerConcurrency,omitempty" tf:"worker_concurrency,omitempty"`
}

type VirtualCenterObservation struct {
	Datacenters *string `json:"datacenters,omitempty" tf:"datacenters,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`
}

type VirtualCenterParameters struct {

	// +kubebuilder:validation:Required
	Datacenters *string `json:"datacenters" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Required
	UserSecretRef v1.SecretKeySelector `json:"userSecretRef" tf:"-"`
}

type VsphereCloudProviderGlobalObservation struct {
	Datacenters *string `json:"datacenters,omitempty" tf:"datacenters,omitempty"`

	InsecureFlag *bool `json:"insecureFlag,omitempty" tf:"insecure_flag,omitempty"`

	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`
}

type VsphereCloudProviderGlobalParameters struct {

	// +kubebuilder:validation:Optional
	Datacenters *string `json:"datacenters,omitempty" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Optional
	InsecureFlag *bool `json:"insecureFlag,omitempty" tf:"insecure_flag,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Optional
	UserSecretRef *v1.SecretKeySelector `json:"userSecretRef,omitempty" tf:"-"`
}

type VsphereCloudProviderObservation struct {
	Disk []DiskObservation `json:"disk,omitempty" tf:"disk,omitempty"`

	Global []VsphereCloudProviderGlobalObservation `json:"global,omitempty" tf:"global,omitempty"`

	Network []NetworkObservation `json:"network,omitempty" tf:"network,omitempty"`

	VirtualCenter []VirtualCenterObservation `json:"virtualCenter,omitempty" tf:"virtual_center,omitempty"`

	Workspace []WorkspaceObservation `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type VsphereCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	Disk []DiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// +kubebuilder:validation:Optional
	Global []VsphereCloudProviderGlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	Network []NetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// +kubebuilder:validation:Required
	VirtualCenter []VirtualCenterParameters `json:"virtualCenter" tf:"virtual_center,omitempty"`

	// +kubebuilder:validation:Required
	Workspace []WorkspaceParameters `json:"workspace" tf:"workspace,omitempty"`
}

type WeaveNetworkProviderObservation struct {
	Password *string `json:"password,omitempty" tf:"password,omitempty"`
}

type WeaveNetworkProviderParameters struct {

	// +kubebuilder:validation:Required
	Password *string `json:"password" tf:"password,omitempty"`
}

type WorkspaceObservation struct {
	Datacenter *string `json:"datacenter,omitempty" tf:"datacenter,omitempty"`

	DefaultDatastore *string `json:"defaultDatastore,omitempty" tf:"default_datastore,omitempty"`

	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	ResourcepoolPath *string `json:"resourcepoolPath,omitempty" tf:"resourcepool_path,omitempty"`

	Server *string `json:"server,omitempty" tf:"server,omitempty"`
}

type WorkspaceParameters struct {

	// +kubebuilder:validation:Required
	Datacenter *string `json:"datacenter" tf:"datacenter,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultDatastore *string `json:"defaultDatastore,omitempty" tf:"default_datastore,omitempty"`

	// +kubebuilder:validation:Required
	Folder *string `json:"folder" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	ResourcepoolPath *string `json:"resourcepoolPath,omitempty" tf:"resourcepool_path,omitempty"`

	// +kubebuilder:validation:Required
	Server *string `json:"server" tf:"server,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancher}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
